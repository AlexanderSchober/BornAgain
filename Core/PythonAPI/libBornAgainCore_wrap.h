/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 3.0.8
 *
 * This file is not intended to be easily readable and contains a number of
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG
 * interface file instead.
 * ----------------------------------------------------------------------------- */

#ifndef SWIG_libBornAgainCore_WRAP_H_
#define SWIG_libBornAgainCore_WRAP_H_

#include <map>
#include <string>


class SwigDirector_ICloneable : public ICloneable, public Swig::Director {

public:
    SwigDirector_ICloneable(PyObject *self);
    virtual ~SwigDirector_ICloneable();
    virtual ICloneable *clone() const;
    virtual void transferToCPP();

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class ICloneable doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[2];
#endif

};


class SwigDirector_INamed : public INamed, public Swig::Director {

public:
    SwigDirector_INamed(PyObject *self);
    SwigDirector_INamed(PyObject *self, std::string name);
    virtual ~SwigDirector_INamed();

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;
};


class SwigDirector_INamedShared : public INamedShared, public Swig::Director {

public:
    SwigDirector_INamedShared(PyObject *self);
    SwigDirector_INamedShared(PyObject *self, std::string name);
    virtual ~SwigDirector_INamedShared();

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;
};


class SwigDirector_IParameterized : public IParameterized, public Swig::Director {

public:
    SwigDirector_IParameterized(PyObject *self);
    SwigDirector_IParameterized(PyObject *self, std::string const &name);
    SwigDirector_IParameterized(PyObject *self, IParameterized const &other);
    virtual ~SwigDirector_IParameterized();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      IParameterized::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      IParameterized::init_parameters();
    }

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class IParameterized doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[4];
#endif

};


class SwigDirector_IParameterizedShared : public IParameterizedShared, public Swig::Director {

public:
    SwigDirector_IParameterizedShared(PyObject *self);
    SwigDirector_IParameterizedShared(PyObject *self, std::string const &name);
    SwigDirector_IParameterizedShared(PyObject *self, IParameterizedShared const &other);
    virtual ~SwigDirector_IParameterizedShared();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      IParameterizedShared::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      IParameterizedShared::init_parameters();
    }

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class IParameterizedShared doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[4];
#endif

};


class SwigDirector_IAxis : public IAxis, public Swig::Director {

public:
    SwigDirector_IAxis(PyObject *self, std::string const &name);
    virtual IAxis *clone() const;
    virtual IAxis *createDoubleBinSize() const;
    virtual ~SwigDirector_IAxis();
    virtual size_t getSize() const;
    virtual double operator [](size_t index) const;
    virtual Bin1D getBin(size_t index) const;
    virtual double getMin() const;
    virtual double getMax() const;
    virtual double getBinCenter(size_t index) const;
    virtual size_t findClosestIndex(double value) const;
    virtual std::vector< double,std::allocator< double > > getBinCenters() const;
    virtual std::vector< double,std::allocator< double > > getBinBoundaries() const;
    virtual IAxis *createClippedAxis(double left, double right) const;
    virtual bool contains(double value) const;
    virtual void print(std::ostream &ostr) const;
    virtual bool equals(IAxis const &other) const;
    virtual bool equalsSwigPublic(IAxis const &other) const {
      return IAxis::equals(other);
    }

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class IAxis doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[14];
#endif

};


class SwigDirector_IShape2D : public Geometry::IShape2D, public Swig::Director {

public:
    SwigDirector_IShape2D(PyObject *self);
    virtual ~SwigDirector_IShape2D();
    virtual Geometry::IShape2D *clone() const;
    virtual void transferToCPP();
    virtual bool contains(double x, double y) const;
    virtual bool contains(Bin1D const &binx, Bin1D const &biny) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      Geometry::IShape2D::print(ostr);
    }

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class IShape2D doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[5];
#endif

};


class SwigDirector_ISample : public ISample, public Swig::Director {

public:
    SwigDirector_ISample(PyObject *self);
    virtual ~SwigDirector_ISample();
    virtual ISample *clone() const;
    virtual void transferToCPP();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      IParameterized::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      IParameterized::init_parameters();
    }
    virtual ISample *cloneInvertB() const;
    virtual void accept(ISampleVisitor *p_visitor) const;
    virtual DWBASimulation *createDWBASimulation() const;
    virtual void printSampleTree();
    virtual bool containsMagneticMaterial() const;
    virtual std::vector< ISample const *,std::allocator< ISample const * > > getChildren() const;
    virtual size_t size() const;

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class ISample doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[13];
#endif

};


class SwigDirector_ISampleBuilder : public ISampleBuilder, public Swig::Director {

public:
    SwigDirector_ISampleBuilder(PyObject *self);
    virtual ~SwigDirector_ISampleBuilder();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      IParameterizedShared::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      IParameterizedShared::init_parameters();
    }
    virtual ISample *buildSample() const;
    virtual void init_from(IComponentService const *arg0);

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class ISampleBuilder doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[6];
#endif

};


class SwigDirector_ICompositeSample : public ICompositeSample, public Swig::Director {

public:
    SwigDirector_ICompositeSample(PyObject *self);
    virtual ~SwigDirector_ICompositeSample();
    virtual ICompositeSample *clone() const;
    virtual void transferToCPP();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      IParameterized::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      IParameterized::init_parameters();
    }
    virtual ISample *cloneInvertB() const;
    virtual void accept(ISampleVisitor *visitor) const;
    virtual DWBASimulation *createDWBASimulation() const;
    virtual void printSampleTree();
    virtual bool containsMagneticMaterial() const;
    virtual std::vector< ISample const *,std::allocator< ISample const * > > getChildren() const;
    virtual size_t size() const;
    virtual void registerChild(ISample *sample);
    virtual void deregisterChild(ISample *sample);

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class ICompositeSample doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[15];
#endif

};


class SwigDirector_IClusteredParticles : public IClusteredParticles, public Swig::Director {

public:
    SwigDirector_IClusteredParticles(PyObject *self);
    virtual ~SwigDirector_IClusteredParticles();
    virtual IClusteredParticles *clone() const;
    virtual void transferToCPP();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      IParameterized::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      IParameterized::init_parameters();
    }
    virtual IClusteredParticles *cloneInvertB() const;
    virtual void accept(ISampleVisitor *visitor) const;
    virtual DWBASimulation *createDWBASimulation() const;
    virtual void printSampleTree();
    virtual bool containsMagneticMaterial() const;
    virtual std::vector< ISample const *,std::allocator< ISample const * > > getChildren() const;
    virtual size_t size() const;
    virtual void registerChild(ISample *sample);
    virtual void deregisterChild(ISample *sample);
    virtual void setAmbientMaterial(IMaterial const &material);
    virtual IMaterial const *getAmbientMaterial() const;
    virtual IFormFactor *createTotalFormFactor(IFormFactor const &meso_crystal_form_factor, IRotation const *p_rotation, kvector_t translation) const;
    virtual void applyRotation(IRotation const &rotation);

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class IClusteredParticles doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[19];
#endif

};


class SwigDirector_IFormFactor : public IFormFactor, public Swig::Director {

public:
    SwigDirector_IFormFactor(PyObject *self);
    virtual ~SwigDirector_IFormFactor();
    virtual IFormFactor *clone() const;
    virtual void transferToCPP();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      IParameterized::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      IParameterized::init_parameters();
    }
    virtual ISample *cloneInvertB() const;
    virtual void accept(ISampleVisitor *visitor) const;
    virtual DWBASimulation *createDWBASimulation() const;
    virtual void printSampleTree();
    virtual bool containsMagneticMaterial() const;
    virtual std::vector< ISample const *,std::allocator< ISample const * > > getChildren() const;
    virtual size_t size() const;
    virtual void setAmbientMaterial(IMaterial const &arg0);
    virtual complex_t evaluate(WavevectorInfo const &wavevectors) const;
    virtual double getVolume() const;
    virtual double getRadius() const;
    virtual void setSpecularInfo(ILayerRTCoefficients const *p_in_coeffs, ILayerRTCoefficients const *p_out_coeffs);

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class IFormFactor doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[18];
#endif

};


class SwigDirector_IFormFactorBorn : public IFormFactorBorn, public Swig::Director {

public:
    SwigDirector_IFormFactorBorn(PyObject *self);
    virtual ~SwigDirector_IFormFactorBorn();
    virtual IFormFactorBorn *clone() const;
    virtual void transferToCPP();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      IParameterized::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      IParameterized::init_parameters();
    }
    virtual ISample *cloneInvertB() const;
    virtual void accept(ISampleVisitor *visitor) const;
    virtual DWBASimulation *createDWBASimulation() const;
    virtual void printSampleTree();
    virtual bool containsMagneticMaterial() const;
    virtual std::vector< ISample const *,std::allocator< ISample const * > > getChildren() const;
    virtual size_t size() const;
    virtual void setAmbientMaterial(IMaterial const &arg0);
    virtual complex_t evaluate(WavevectorInfo const &wavevectors) const;
    virtual double getVolume() const;
    virtual double getRadius() const;
    virtual void setSpecularInfo(ILayerRTCoefficients const *p_in_coeffs, ILayerRTCoefficients const *p_out_coeffs);
    virtual complex_t evaluate_for_q(cvector_t const &q) const;
    virtual bool check_initialization() const;
    virtual bool check_initializationSwigPublic() const {
      return IFormFactorBorn::check_initialization();
    }

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class IFormFactorBorn doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[20];
#endif

};


class SwigDirector_IFormFactorDecorator : public IFormFactorDecorator, public Swig::Director {

public:
    SwigDirector_IFormFactorDecorator(PyObject *self, IFormFactor const &form_factor);
    virtual ~SwigDirector_IFormFactorDecorator();
    virtual IFormFactorDecorator *clone() const;
    virtual void transferToCPP();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      IParameterized::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      IParameterized::init_parameters();
    }
    virtual ISample *cloneInvertB() const;
    virtual void accept(ISampleVisitor *visitor) const;
    virtual DWBASimulation *createDWBASimulation() const;
    virtual void printSampleTree();
    virtual bool containsMagneticMaterial() const;
    virtual std::vector< ISample const *,std::allocator< ISample const * > > getChildren() const;
    virtual size_t size() const;
    virtual void setAmbientMaterial(IMaterial const &material);
    virtual complex_t evaluate(WavevectorInfo const &wavevectors) const;
    virtual double getVolume() const;
    virtual double getRadius() const;
    virtual void setSpecularInfo(ILayerRTCoefficients const *p_in_coeffs, ILayerRTCoefficients const *p_out_coeffs);

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class IFormFactorDecorator doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[18];
#endif

};


class SwigDirector_IHistogram : public IHistogram, public Swig::Director {

public:
    SwigDirector_IHistogram(PyObject *self);
    SwigDirector_IHistogram(PyObject *self, IHistogram const &other);
    SwigDirector_IHistogram(PyObject *self, IAxis const &axis_x);
    SwigDirector_IHistogram(PyObject *self, IAxis const &axis_x, IAxis const &axis_y);
    virtual ~SwigDirector_IHistogram();
    virtual IHistogram *clone() const;
    virtual size_t getRank() const;

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class IHistogram doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[2];
#endif

};


class SwigDirector_IMaterial : public IMaterial, public Swig::Director {

public:
    SwigDirector_IMaterial(PyObject *self, std::string const &name);
    virtual ~SwigDirector_IMaterial();
    virtual IMaterial *clone() const;
    virtual bool isScalarMaterial() const;
    virtual complex_t getRefractiveIndex() const;
    virtual IMaterial const *createTransformedMaterial(IRotation const &rotation) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      IMaterial::print(ostr);
    }

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class IMaterial doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[5];
#endif

};


class SwigDirector_IDetector2D : public IDetector2D, public Swig::Director {

public:
    SwigDirector_IDetector2D(PyObject *self);
    SwigDirector_IDetector2D(PyObject *self, IDetector2D const &other);
    virtual ~SwigDirector_IDetector2D();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      IParameterized::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      IDetector2D::init_parameters();
    }
    virtual IDetector2D *clone() const;
    virtual void init(Beam const &beam);
    virtual OutputData< double > *createDetectorMap(Beam const &beam, IDetector2D::EAxesUnits units_type) const;
    virtual std::vector< IDetector2D::EAxesUnits,std::allocator< IDetector2D::EAxesUnits > > getValidAxesUnits() const;
    virtual IDetector2D::EAxesUnits getDefaultAxesUnits() const;
    virtual IPixelMap *createPixelMap(size_t index) const;
    virtual IAxis *createAxis(size_t index, size_t n_bins, double min, double max) const;
    virtual std::string getAxisName(size_t index) const;

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class IDetector2D doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[12];
#endif

};


class SwigDirector_IInterferenceFunction : public IInterferenceFunction, public Swig::Director {

public:
    SwigDirector_IInterferenceFunction(PyObject *self);
    virtual ~SwigDirector_IInterferenceFunction();
    virtual IInterferenceFunction *clone() const;
    virtual void transferToCPP();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      IParameterized::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      IParameterized::init_parameters();
    }
    virtual ISample *cloneInvertB() const;
    virtual void accept(ISampleVisitor *visitor) const;
    virtual DWBASimulation *createDWBASimulation() const;
    virtual void printSampleTree();
    virtual bool containsMagneticMaterial() const;
    virtual std::vector< ISample const *,std::allocator< ISample const * > > getChildren() const;
    virtual size_t size() const;
    virtual double evaluate(kvector_t const &q) const;
    virtual double getKappa() const;
    virtual double getParticleDensity() const;

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class IInterferenceFunction doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[16];
#endif

};


class SwigDirector_ILayout : public ILayout, public Swig::Director {

public:
    SwigDirector_ILayout(PyObject *self);
    virtual ~SwigDirector_ILayout();
    virtual ILayout *clone() const;
    virtual void transferToCPP();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      IParameterized::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      IParameterized::init_parameters();
    }
    virtual ILayout *cloneInvertB() const;
    virtual void accept(ISampleVisitor *visitor) const;
    virtual DWBASimulation *createDWBASimulation() const;
    virtual void printSampleTree();
    virtual bool containsMagneticMaterial() const;
    virtual std::vector< ISample const *,std::allocator< ISample const * > > getChildren() const;
    virtual size_t size() const;
    virtual void registerChild(ISample *sample);
    virtual void deregisterChild(ISample *sample);
    virtual size_t getNumberOfParticles() const;
    virtual IAbstractParticle const *getParticle(size_t index) const;
    virtual SafePointerVector< IParticle const > getParticles() const;
    virtual double getAbundanceOfParticle(size_t index) const;
    virtual IInterferenceFunction const *getInterferenceFunction() const;
    virtual double getTotalParticleSurfaceDensity() const;
    virtual void setTotalParticleSurfaceDensity(double particle_density);

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class ILayout doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[22];
#endif

};


class SwigDirector_IObserver : public IObserver, public Swig::Director {

public:
    SwigDirector_IObserver(PyObject *self);
    virtual ~SwigDirector_IObserver();
    virtual void notify(IObservable *subject);

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class IObserver doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[1];
#endif

};


class SwigDirector_IAbstractParticle : public IAbstractParticle, public Swig::Director {

public:
    SwigDirector_IAbstractParticle(PyObject *self);
    virtual ~SwigDirector_IAbstractParticle();
    virtual IAbstractParticle *clone() const;
    virtual void transferToCPP();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      IParameterized::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      IParameterized::init_parameters();
    }
    virtual IAbstractParticle *cloneInvertB() const;
    virtual void accept(ISampleVisitor *visitor) const;
    virtual DWBASimulation *createDWBASimulation() const;
    virtual void printSampleTree();
    virtual bool containsMagneticMaterial() const;
    virtual std::vector< ISample const *,std::allocator< ISample const * > > getChildren() const;
    virtual size_t size() const;
    virtual void registerChild(ISample *sample);
    virtual void deregisterChild(ISample *sample);
    virtual void setAmbientMaterial(IMaterial const &material);
    virtual IMaterial const *getAmbientMaterial() const;

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class IAbstractParticle doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[17];
#endif

};


class SwigDirector_IParticle : public IParticle, public Swig::Director {

public:
    SwigDirector_IParticle(PyObject *self);
    virtual ~SwigDirector_IParticle();
    virtual IParticle *clone() const;
    virtual void transferToCPP();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      IParameterized::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      IParameterized::init_parameters();
    }
    virtual IParticle *cloneInvertB() const;
    virtual void accept(ISampleVisitor *visitor) const;
    virtual DWBASimulation *createDWBASimulation() const;
    virtual void printSampleTree();
    virtual bool containsMagneticMaterial() const;
    virtual std::vector< ISample const *,std::allocator< ISample const * > > getChildren() const;
    virtual size_t size() const;
    virtual void registerChild(ISample *sample);
    virtual void deregisterChild(ISample *sample);
    virtual void setAmbientMaterial(IMaterial const &material);
    virtual IMaterial const *getAmbientMaterial() const;
    virtual IFormFactor *createTransformedFormFactor(IRotation const *p_rotation, kvector_t translation) const;

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class IParticle doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[18];
#endif

};


class SwigDirector_IResolutionFunction2D : public IResolutionFunction2D, public Swig::Director {

public:
    SwigDirector_IResolutionFunction2D(PyObject *self);
    virtual ~SwigDirector_IResolutionFunction2D();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      IParameterized::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      IParameterized::init_parameters();
    }
    virtual double evaluateCDF(double x, double y) const;
    virtual IResolutionFunction2D *clone() const;

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class IResolutionFunction2D doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[6];
#endif

};


class SwigDirector_IRotation : public IRotation, public Swig::Director {

public:
    SwigDirector_IRotation(PyObject *self);
    virtual ~SwigDirector_IRotation();
    virtual IRotation *clone() const;
    virtual void transferToCPP();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      IParameterized::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      IParameterized::init_parameters();
    }
    virtual IRotation *cloneInvertB() const;
    virtual void accept(ISampleVisitor *visitor) const;
    virtual DWBASimulation *createDWBASimulation() const;
    virtual void printSampleTree();
    virtual bool containsMagneticMaterial() const;
    virtual std::vector< ISample const *,std::allocator< ISample const * > > getChildren() const;
    virtual size_t size() const;
    virtual IRotation *createInverse() const;
    virtual Geometry::Transform3D getTransform3D() const;
    virtual bool isIdentity() const;

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class IRotation doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[16];
#endif

};


class SwigDirector_ISelectionRule : public ISelectionRule, public Swig::Director {

public:
    SwigDirector_ISelectionRule(PyObject *self);
    virtual ~SwigDirector_ISelectionRule();
    virtual ISelectionRule *clone() const;
    virtual bool coordinateSelected(IndexVector3D const &coordinate) const;

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class ISelectionRule doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[2];
#endif

};


class SwigDirector_Instrument : public Instrument, public Swig::Director {

public:
    SwigDirector_Instrument(PyObject *self);
    SwigDirector_Instrument(PyObject *self, Instrument const &other);
    virtual ~SwigDirector_Instrument();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      Instrument::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      Instrument::init_parameters();
    }

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class Instrument doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[4];
#endif

};


class SwigDirector_InterferenceFunction1DLattice : public InterferenceFunction1DLattice, public Swig::Director {

public:
    SwigDirector_InterferenceFunction1DLattice(PyObject *self, double length, double xi);
    virtual ~SwigDirector_InterferenceFunction1DLattice();
    virtual InterferenceFunction1DLattice *clone() const;
    virtual void transferToCPP();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      IParameterized::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      IParameterized::init_parameters();
    }
    virtual ISample *cloneInvertB() const;
    virtual void accept(ISampleVisitor *visitor) const;
    virtual DWBASimulation *createDWBASimulation() const;
    virtual void printSampleTree();
    virtual bool containsMagneticMaterial() const;
    virtual std::vector< ISample const *,std::allocator< ISample const * > > getChildren() const;
    virtual size_t size() const;
    virtual double evaluate(kvector_t const &q) const;
    virtual double getKappa() const;
    virtual double getParticleDensity() const;

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class InterferenceFunction1DLattice doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[16];
#endif

};


class SwigDirector_InterferenceFunctionRadialParaCrystal : public InterferenceFunctionRadialParaCrystal, public Swig::Director {

public:
    SwigDirector_InterferenceFunctionRadialParaCrystal(PyObject *self, double peak_distance, double damping_length = 0.0);
    virtual ~SwigDirector_InterferenceFunctionRadialParaCrystal();
    virtual InterferenceFunctionRadialParaCrystal *clone() const;
    virtual void transferToCPP();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      IParameterized::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      IParameterized::init_parameters();
    }
    virtual ISample *cloneInvertB() const;
    virtual void accept(ISampleVisitor *visitor) const;
    virtual DWBASimulation *createDWBASimulation() const;
    virtual void printSampleTree();
    virtual bool containsMagneticMaterial() const;
    virtual std::vector< ISample const *,std::allocator< ISample const * > > getChildren() const;
    virtual size_t size() const;
    virtual double evaluate(kvector_t const &q) const;
    virtual double getKappa() const;
    virtual double getParticleDensity() const;

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class InterferenceFunctionRadialParaCrystal doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[16];
#endif

};


class SwigDirector_InterferenceFunction2DLattice : public InterferenceFunction2DLattice, public Swig::Director {

public:
    SwigDirector_InterferenceFunction2DLattice(PyObject *self, double length_1, double length_2, double angle, double xi = 0.0);
    virtual ~SwigDirector_InterferenceFunction2DLattice();
    virtual InterferenceFunction2DLattice *clone() const;
    virtual void transferToCPP();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      IParameterized::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      IParameterized::init_parameters();
    }
    virtual ISample *cloneInvertB() const;
    virtual void accept(ISampleVisitor *visitor) const;
    virtual DWBASimulation *createDWBASimulation() const;
    virtual void printSampleTree();
    virtual bool containsMagneticMaterial() const;
    virtual std::vector< ISample const *,std::allocator< ISample const * > > getChildren() const;
    virtual size_t size() const;
    virtual double evaluate(kvector_t const &q) const;
    virtual double getKappa() const;
    virtual double getParticleDensity() const;

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class InterferenceFunction2DLattice doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[16];
#endif

};


class SwigDirector_InterferenceFunction2DParaCrystal : public InterferenceFunction2DParaCrystal, public Swig::Director {

public:
    SwigDirector_InterferenceFunction2DParaCrystal(PyObject *self, double length_1, double length_2, double alpha_lattice, double xi = 0.0, double damping_length = 0.0);
    virtual ~SwigDirector_InterferenceFunction2DParaCrystal();
    virtual InterferenceFunction2DParaCrystal *clone() const;
    virtual void transferToCPP();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      IParameterized::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      InterferenceFunction2DParaCrystal::init_parameters();
    }
    virtual ISample *cloneInvertB() const;
    virtual void accept(ISampleVisitor *visitor) const;
    virtual DWBASimulation *createDWBASimulation() const;
    virtual void printSampleTree();
    virtual bool containsMagneticMaterial() const;
    virtual std::vector< ISample const *,std::allocator< ISample const * > > getChildren() const;
    virtual size_t size() const;
    virtual double evaluate(kvector_t const &q) const;
    virtual double getKappa() const;
    virtual double getParticleDensity() const;

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class InterferenceFunction2DParaCrystal doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[16];
#endif

};


class SwigDirector_InterferenceFunctionNone : public InterferenceFunctionNone, public Swig::Director {

public:
    SwigDirector_InterferenceFunctionNone(PyObject *self);
    virtual ~SwigDirector_InterferenceFunctionNone();
    virtual InterferenceFunctionNone *clone() const;
    virtual void transferToCPP();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      IParameterized::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      IParameterized::init_parameters();
    }
    virtual ISample *cloneInvertB() const;
    virtual void accept(ISampleVisitor *visitor) const;
    virtual DWBASimulation *createDWBASimulation() const;
    virtual void printSampleTree();
    virtual bool containsMagneticMaterial() const;
    virtual std::vector< ISample const *,std::allocator< ISample const * > > getChildren() const;
    virtual size_t size() const;
    virtual double evaluate(kvector_t const &q) const;
    virtual double getKappa() const;
    virtual double getParticleDensity() const;

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class InterferenceFunctionNone doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[16];
#endif

};


class SwigDirector_IsGISAXSDetector : public IsGISAXSDetector, public Swig::Director {

public:
    SwigDirector_IsGISAXSDetector(PyObject *self);
    SwigDirector_IsGISAXSDetector(PyObject *self, size_t n_phi, double phi_min, double phi_max, size_t n_alpha, double alpha_min, double alpha_max);
    SwigDirector_IsGISAXSDetector(PyObject *self, IsGISAXSDetector const &other);
    virtual ~SwigDirector_IsGISAXSDetector();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      IsGISAXSDetector::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      SphericalDetector::init_parameters();
    }
    virtual IsGISAXSDetector *clone() const;
    virtual void init(Beam const &beam);
    virtual OutputData< double > *createDetectorMap(Beam const &beam, IDetector2D::EAxesUnits units_type) const;
    virtual std::vector< IDetector2D::EAxesUnits,std::allocator< IDetector2D::EAxesUnits > > getValidAxesUnits() const;
    virtual IDetector2D::EAxesUnits getDefaultAxesUnits() const;
    virtual IPixelMap *createPixelMap(size_t index) const;
    virtual IPixelMap *createPixelMapSwigPublic(size_t index) const {
      return SphericalDetector::createPixelMap(index);
    }
    virtual IAxis *createAxis(size_t index, size_t n_bins, double min, double max) const;
    virtual IAxis *createAxisSwigPublic(size_t index, size_t n_bins, double min, double max) const {
      return IsGISAXSDetector::createAxis(index,n_bins,min,max);
    }
    virtual std::string getAxisName(size_t index) const;
    virtual std::string getAxisNameSwigPublic(size_t index) const {
      return SphericalDetector::getAxisName(index);
    }

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class IsGISAXSDetector doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[12];
#endif

};


#endif
