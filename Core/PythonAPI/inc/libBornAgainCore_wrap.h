/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 3.0.8
 *
 * This file is not intended to be easily readable and contains a number of
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG
 * interface file instead.
 * ----------------------------------------------------------------------------- */

#ifndef SWIG_libBornAgainCore_WRAP_H_
#define SWIG_libBornAgainCore_WRAP_H_

#include <map>
#include <string>


class SwigDirector_IAxis : public IAxis, public Swig::Director {

public:
    SwigDirector_IAxis(PyObject *self, std::string const &name);
    virtual IAxis *clone() const;
    virtual IAxis *createDoubleBinSize() const;
    virtual ~SwigDirector_IAxis();
    virtual size_t getSize() const;
    virtual double operator [](size_t index) const;
    virtual Bin1D getBin(size_t index) const;
    virtual double getMin() const;
    virtual double getMax() const;
    virtual double getBinCenter(size_t index) const;
    virtual size_t findClosestIndex(double value) const;
    virtual std::vector< double,std::allocator< double > > getBinCenters() const;
    virtual std::vector< double,std::allocator< double > > getBinBoundaries() const;
    virtual IAxis *createClippedAxis(double left, double right) const;
    virtual bool contains(double value) const;
    virtual void print(std::ostream &ostr) const;
    virtual bool equals(IAxis const &other) const;
    virtual bool equalsSwigPublic(IAxis const &other) const {
      return IAxis::equals(other);
    }

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class IAxis doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[14];
#endif

};


class SwigDirector_VariableBinAxis : public VariableBinAxis, public Swig::Director {

public:
    SwigDirector_VariableBinAxis(PyObject *self, std::string const &name, size_t nbins, std::vector< double,std::allocator< double > > const &bin_boundaries);
    SwigDirector_VariableBinAxis(PyObject *self, std::string const &name, int nbins = 0);
    virtual VariableBinAxis *clone() const;
    virtual IAxis *createDoubleBinSize() const;
    virtual ~SwigDirector_VariableBinAxis();
    virtual size_t getSize() const;
    virtual double operator [](size_t index) const;
    virtual Bin1D getBin(size_t index) const;
    virtual double getMin() const;
    virtual double getMax() const;
    virtual double getBinCenter(size_t index) const;
    virtual size_t findClosestIndex(double value) const;
    virtual std::vector< double,std::allocator< double > > getBinCenters() const;
    virtual std::vector< double,std::allocator< double > > getBinBoundaries() const;
    virtual VariableBinAxis *createClippedAxis(double left, double right) const;
    virtual bool contains(double value) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      VariableBinAxis::print(ostr);
    }
    virtual bool equals(IAxis const &other) const;
    virtual bool equalsSwigPublic(IAxis const &other) const {
      return VariableBinAxis::equals(other);
    }

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class VariableBinAxis doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[14];
#endif

};


class SwigDirector_ConstKBinAxis : public ConstKBinAxis, public Swig::Director {

public:
    SwigDirector_ConstKBinAxis(PyObject *self, std::string const &name, size_t nbins, double start, double end);
    SwigDirector_ConstKBinAxis(PyObject *self, std::string const &name, size_t nbins);
    virtual ConstKBinAxis *clone() const;
    virtual IAxis *createDoubleBinSize() const;
    virtual ~SwigDirector_ConstKBinAxis();
    virtual size_t getSize() const;
    virtual double operator [](size_t index) const;
    virtual Bin1D getBin(size_t index) const;
    virtual double getMin() const;
    virtual double getMax() const;
    virtual double getBinCenter(size_t index) const;
    virtual size_t findClosestIndex(double value) const;
    virtual std::vector< double,std::allocator< double > > getBinCenters() const;
    virtual std::vector< double,std::allocator< double > > getBinBoundaries() const;
    virtual ConstKBinAxis *createClippedAxis(double left, double right) const;
    virtual bool contains(double value) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      ConstKBinAxis::print(ostr);
    }
    virtual bool equals(IAxis const &other) const;
    virtual bool equalsSwigPublic(IAxis const &other) const {
      return ConstKBinAxis::equals(other);
    }

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class ConstKBinAxis doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[14];
#endif

};


class SwigDirector_ICloneable : public ICloneable, public Swig::Director {

public:
    SwigDirector_ICloneable(PyObject *self);
    virtual ~SwigDirector_ICloneable();
    virtual ICloneable *clone() const;
    virtual void transferToCPP();

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class ICloneable doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[2];
#endif

};


class SwigDirector_INamed : public INamed, public Swig::Director {

public:
    SwigDirector_INamed(PyObject *self);
    SwigDirector_INamed(PyObject *self, std::string name);
    virtual ~SwigDirector_INamed();

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;
};


class SwigDirector_IParameterized : public IParameterized, public Swig::Director {

public:
    SwigDirector_IParameterized(PyObject *self);
    SwigDirector_IParameterized(PyObject *self, std::string const &name);
    SwigDirector_IParameterized(PyObject *self, IParameterized const &other);
    virtual ~SwigDirector_IParameterized();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      IParameterized::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      IParameterized::init_parameters();
    }

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class IParameterized doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[4];
#endif

};


class SwigDirector_ISample : public ISample, public Swig::Director {

public:
    SwigDirector_ISample(PyObject *self);
    virtual ~SwigDirector_ISample();
    virtual ISample *clone() const;
    virtual void transferToCPP();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      IParameterized::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      IParameterized::init_parameters();
    }
    virtual ISample *cloneInvertB() const;
    virtual void accept(ISampleVisitor *p_visitor) const;
    virtual DWBASimulation *createDWBASimulation() const;
    virtual void printSampleTree();
    virtual bool containsMagneticMaterial() const;
    virtual std::vector< ISample const *,std::allocator< ISample const * > > getChildren() const;
    virtual size_t size() const;

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class ISample doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[13];
#endif

};


class SwigDirector_ICompositeSample : public ICompositeSample, public Swig::Director {

public:
    SwigDirector_ICompositeSample(PyObject *self);
    virtual ~SwigDirector_ICompositeSample();
    virtual ICompositeSample *clone() const;
    virtual void transferToCPP();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      IParameterized::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      IParameterized::init_parameters();
    }
    virtual ISample *cloneInvertB() const;
    virtual void accept(ISampleVisitor *visitor) const;
    virtual DWBASimulation *createDWBASimulation() const;
    virtual void printSampleTree();
    virtual bool containsMagneticMaterial() const;
    virtual std::vector< ISample const *,std::allocator< ISample const * > > getChildren() const;
    virtual size_t size() const;
    virtual void registerChild(ISample *sample);
    virtual void deregisterChild(ISample *sample);

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class ICompositeSample doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[15];
#endif

};


class SwigDirector_IClusteredParticles : public IClusteredParticles, public Swig::Director {

public:
    SwigDirector_IClusteredParticles(PyObject *self);
    virtual ~SwigDirector_IClusteredParticles();
    virtual IClusteredParticles *clone() const;
    virtual void transferToCPP();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      IParameterized::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      IParameterized::init_parameters();
    }
    virtual IClusteredParticles *cloneInvertB() const;
    virtual void accept(ISampleVisitor *visitor) const;
    virtual DWBASimulation *createDWBASimulation() const;
    virtual void printSampleTree();
    virtual bool containsMagneticMaterial() const;
    virtual std::vector< ISample const *,std::allocator< ISample const * > > getChildren() const;
    virtual size_t size() const;
    virtual void registerChild(ISample *sample);
    virtual void deregisterChild(ISample *sample);
    virtual void setAmbientMaterial(IMaterial const &material);
    virtual IMaterial const *getAmbientMaterial() const;
    virtual IFormFactor *createTotalFormFactor(IFormFactor const &meso_crystal_form_factor, IRotation const *p_rotation, kvector_t translation) const;
    virtual void applyRotation(IRotation const &rotation);

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class IClusteredParticles doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[19];
#endif

};


class SwigDirector_IShape2D : public Geometry::IShape2D, public Swig::Director {

public:
    SwigDirector_IShape2D(PyObject *self);
    virtual ~SwigDirector_IShape2D();
    virtual Geometry::IShape2D *clone() const;
    virtual void transferToCPP();
    virtual bool contains(double x, double y) const;
    virtual bool contains(Bin1D const &binx, Bin1D const &biny) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      Geometry::IShape2D::print(ostr);
    }

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class IShape2D doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[5];
#endif

};


class SwigDirector_Crystal : public Crystal, public Swig::Director {

public:
    SwigDirector_Crystal(PyObject *self, ParticleComposition const &lattice_basis, Lattice const &lattice);
    virtual ~SwigDirector_Crystal();
    virtual Crystal *clone() const;
    virtual void transferToCPP();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      IParameterized::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      IParameterized::init_parameters();
    }
    virtual Crystal *cloneInvertB() const;
    virtual void accept(ISampleVisitor *visitor) const;
    virtual DWBASimulation *createDWBASimulation() const;
    virtual void printSampleTree();
    virtual bool containsMagneticMaterial() const;
    virtual std::vector< ISample const *,std::allocator< ISample const * > > getChildren() const;
    virtual size_t size() const;
    virtual void registerChild(ISample *sample);
    virtual void deregisterChild(ISample *sample);
    virtual void setAmbientMaterial(IMaterial const &material);
    virtual IMaterial const *getAmbientMaterial() const;
    virtual IFormFactor *createTotalFormFactor(IFormFactor const &meso_crystal_form_factor, IRotation const *p_rotation, kvector_t translation) const;
    virtual void applyRotation(IRotation const &rotation);

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class Crystal doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[19];
#endif

};


class SwigDirector_CustomBinAxis : public CustomBinAxis, public Swig::Director {

public:
    SwigDirector_CustomBinAxis(PyObject *self, std::string const &name, size_t nbins, double start, double end);
    virtual CustomBinAxis *clone() const;
    virtual IAxis *createDoubleBinSize() const;
    virtual ~SwigDirector_CustomBinAxis();
    virtual size_t getSize() const;
    virtual double operator [](size_t index) const;
    virtual Bin1D getBin(size_t index) const;
    virtual double getMin() const;
    virtual double getMax() const;
    virtual double getBinCenter(size_t index) const;
    virtual size_t findClosestIndex(double value) const;
    virtual std::vector< double,std::allocator< double > > getBinCenters() const;
    virtual std::vector< double,std::allocator< double > > getBinBoundaries() const;
    virtual CustomBinAxis *createClippedAxis(double left, double right) const;
    virtual bool contains(double value) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      CustomBinAxis::print(ostr);
    }
    virtual bool equals(IAxis const &other) const;
    virtual bool equalsSwigPublic(IAxis const &other) const {
      return CustomBinAxis::equals(other);
    }

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class CustomBinAxis doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[14];
#endif

};


class SwigDirector_IDistribution1D : public IDistribution1D, public Swig::Director {

public:
    SwigDirector_IDistribution1D(PyObject *self);
    virtual ~SwigDirector_IDistribution1D();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      IParameterized::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      IParameterized::init_parameters();
    }
    virtual IDistribution1D *clone() const;
    virtual double probabilityDensity(double x) const;
    virtual double getMean() const;
    virtual std::vector< double,std::allocator< double > > generateValueList(size_t nbr_samples, double sigma_factor, AttLimits const &limits = AttLimits()) const;
    virtual std::vector< double,std::allocator< double > > generateValues(size_t nbr_samples, double xmin, double xmax) const;

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class IDistribution1D doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[10];
#endif

};


class SwigDirector_DistributionGate : public DistributionGate, public Swig::Director {

public:
    SwigDirector_DistributionGate(PyObject *self);
    SwigDirector_DistributionGate(PyObject *self, double min, double max);
    virtual ~SwigDirector_DistributionGate();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      IParameterized::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      DistributionGate::init_parameters();
    }
    virtual DistributionGate *clone() const;
    virtual double probabilityDensity(double x) const;
    virtual double getMean() const;
    virtual std::vector< double,std::allocator< double > > generateValueList(size_t nbr_samples, double sigma_factor, AttLimits const &limits = AttLimits()) const;
    virtual std::vector< double,std::allocator< double > > generateValues(size_t nbr_samples, double xmin, double xmax) const;

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class DistributionGate doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[10];
#endif

};


class SwigDirector_DistributionLorentz : public DistributionLorentz, public Swig::Director {

public:
    SwigDirector_DistributionLorentz(PyObject *self);
    SwigDirector_DistributionLorentz(PyObject *self, double mean, double hwhm);
    virtual ~SwigDirector_DistributionLorentz();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      IParameterized::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      DistributionLorentz::init_parameters();
    }
    virtual DistributionLorentz *clone() const;
    virtual double probabilityDensity(double x) const;
    virtual double getMean() const;
    virtual std::vector< double,std::allocator< double > > generateValueList(size_t nbr_samples, double sigma_factor, AttLimits const &limits = AttLimits()) const;
    virtual std::vector< double,std::allocator< double > > generateValues(size_t nbr_samples, double xmin, double xmax) const;

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class DistributionLorentz doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[10];
#endif

};


class SwigDirector_DistributionGaussian : public DistributionGaussian, public Swig::Director {

public:
    SwigDirector_DistributionGaussian(PyObject *self);
    SwigDirector_DistributionGaussian(PyObject *self, double mean, double std_dev);
    virtual ~SwigDirector_DistributionGaussian();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      IParameterized::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      DistributionGaussian::init_parameters();
    }
    virtual DistributionGaussian *clone() const;
    virtual double probabilityDensity(double x) const;
    virtual double getMean() const;
    virtual std::vector< double,std::allocator< double > > generateValueList(size_t nbr_samples, double sigma_factor, AttLimits const &limits = AttLimits()) const;
    virtual std::vector< double,std::allocator< double > > generateValues(size_t nbr_samples, double xmin, double xmax) const;

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class DistributionGaussian doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[10];
#endif

};


class SwigDirector_DistributionLogNormal : public DistributionLogNormal, public Swig::Director {

public:
    SwigDirector_DistributionLogNormal(PyObject *self, double scale_param);
    SwigDirector_DistributionLogNormal(PyObject *self, double median, double scale_param);
    virtual ~SwigDirector_DistributionLogNormal();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      IParameterized::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      DistributionLogNormal::init_parameters();
    }
    virtual DistributionLogNormal *clone() const;
    virtual double probabilityDensity(double x) const;
    virtual double getMean() const;
    virtual std::vector< double,std::allocator< double > > generateValueList(size_t nbr_samples, double sigma_factor, AttLimits const &limits = AttLimits()) const;
    virtual std::vector< double,std::allocator< double > > generateValues(size_t nbr_samples, double xmin, double xmax) const;

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class DistributionLogNormal doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[10];
#endif

};


class SwigDirector_DistributionCosine : public DistributionCosine, public Swig::Director {

public:
    SwigDirector_DistributionCosine(PyObject *self);
    SwigDirector_DistributionCosine(PyObject *self, double mean, double sigma);
    virtual ~SwigDirector_DistributionCosine();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      IParameterized::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      DistributionCosine::init_parameters();
    }
    virtual DistributionCosine *clone() const;
    virtual double probabilityDensity(double x) const;
    virtual double getMean() const;
    virtual std::vector< double,std::allocator< double > > generateValueList(size_t nbr_samples, double sigma_factor, AttLimits const &limits = AttLimits()) const;
    virtual std::vector< double,std::allocator< double > > generateValues(size_t nbr_samples, double xmin, double xmax) const;

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class DistributionCosine doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[10];
#endif

};


class SwigDirector_Ellipse : public Geometry::Ellipse, public Swig::Director {

public:
    SwigDirector_Ellipse(PyObject *self, double xcenter, double ycenter, double xradius, double yradius, double theta = 0.0);
    virtual ~SwigDirector_Ellipse();
    virtual Geometry::Ellipse *clone() const;
    virtual void transferToCPP();
    virtual bool contains(double x, double y) const;
    virtual bool contains(Bin1D const &binx, Bin1D const &biny) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      Geometry::IShape2D::print(ostr);
    }

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class Ellipse doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[5];
#endif

};


class SwigDirector_FixedBinAxis : public FixedBinAxis, public Swig::Director {

public:
    SwigDirector_FixedBinAxis(PyObject *self, std::string const &name, size_t nbins, double start, double end);
    virtual FixedBinAxis *clone() const;
    virtual IAxis *createDoubleBinSize() const;
    virtual ~SwigDirector_FixedBinAxis();
    virtual size_t getSize() const;
    virtual double operator [](size_t index) const;
    virtual Bin1D getBin(size_t index) const;
    virtual double getMin() const;
    virtual double getMax() const;
    virtual double getBinCenter(size_t index) const;
    virtual size_t findClosestIndex(double value) const;
    virtual std::vector< double,std::allocator< double > > getBinCenters() const;
    virtual std::vector< double,std::allocator< double > > getBinBoundaries() const;
    virtual FixedBinAxis *createClippedAxis(double left, double right) const;
    virtual bool contains(double value) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      FixedBinAxis::print(ostr);
    }
    virtual bool equals(IAxis const &other) const;
    virtual bool equalsSwigPublic(IAxis const &other) const {
      return FixedBinAxis::equals(other);
    }

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class FixedBinAxis doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[14];
#endif

};


class SwigDirector_IFormFactor : public IFormFactor, public Swig::Director {

public:
    SwigDirector_IFormFactor(PyObject *self);
    virtual ~SwigDirector_IFormFactor();
    virtual IFormFactor *clone() const;
    virtual void transferToCPP();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      IParameterized::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      IParameterized::init_parameters();
    }
    virtual ISample *cloneInvertB() const;
    virtual void accept(ISampleVisitor *visitor) const;
    virtual DWBASimulation *createDWBASimulation() const;
    virtual void printSampleTree();
    virtual bool containsMagneticMaterial() const;
    virtual std::vector< ISample const *,std::allocator< ISample const * > > getChildren() const;
    virtual size_t size() const;
    virtual void setAmbientMaterial(IMaterial const &arg0);
    virtual complex_t evaluate(WavevectorInfo const &wavevectors) const;
    virtual double getVolume() const;
    virtual double getRadius() const;
    virtual void setSpecularInfo(ILayerRTCoefficients const *p_in_coeffs, ILayerRTCoefficients const *p_out_coeffs);

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class IFormFactor doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[18];
#endif

};


class SwigDirector_IFormFactorBorn : public IFormFactorBorn, public Swig::Director {

public:
    SwigDirector_IFormFactorBorn(PyObject *self);
    virtual ~SwigDirector_IFormFactorBorn();
    virtual IFormFactorBorn *clone() const;
    virtual void transferToCPP();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      IParameterized::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      IParameterized::init_parameters();
    }
    virtual ISample *cloneInvertB() const;
    virtual void accept(ISampleVisitor *visitor) const;
    virtual DWBASimulation *createDWBASimulation() const;
    virtual void printSampleTree();
    virtual bool containsMagneticMaterial() const;
    virtual std::vector< ISample const *,std::allocator< ISample const * > > getChildren() const;
    virtual size_t size() const;
    virtual void setAmbientMaterial(IMaterial const &arg0);
    virtual complex_t evaluate(WavevectorInfo const &wavevectors) const;
    virtual double getVolume() const;
    virtual double getRadius() const;
    virtual void setSpecularInfo(ILayerRTCoefficients const *p_in_coeffs, ILayerRTCoefficients const *p_out_coeffs);
    virtual complex_t evaluate_for_q(cvector_t const &q) const;
    virtual bool check_initialization() const;
    virtual bool check_initializationSwigPublic() const {
      return IFormFactorBorn::check_initialization();
    }

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class IFormFactorBorn doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[20];
#endif

};


class SwigDirector_IFormFactorDecorator : public IFormFactorDecorator, public Swig::Director {

public:
    SwigDirector_IFormFactorDecorator(PyObject *self, IFormFactor const &form_factor);
    virtual ~SwigDirector_IFormFactorDecorator();
    virtual IFormFactorDecorator *clone() const;
    virtual void transferToCPP();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      IParameterized::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      IParameterized::init_parameters();
    }
    virtual ISample *cloneInvertB() const;
    virtual void accept(ISampleVisitor *visitor) const;
    virtual DWBASimulation *createDWBASimulation() const;
    virtual void printSampleTree();
    virtual bool containsMagneticMaterial() const;
    virtual std::vector< ISample const *,std::allocator< ISample const * > > getChildren() const;
    virtual size_t size() const;
    virtual void setAmbientMaterial(IMaterial const &material);
    virtual complex_t evaluate(WavevectorInfo const &wavevectors) const;
    virtual double getVolume() const;
    virtual double getRadius() const;
    virtual void setSpecularInfo(ILayerRTCoefficients const *p_in_coeffs, ILayerRTCoefficients const *p_out_coeffs);

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class IFormFactorDecorator doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[18];
#endif

};


class SwigDirector_FormFactorAnisoPyramid : public FormFactorAnisoPyramid, public Swig::Director {

public:
    SwigDirector_FormFactorAnisoPyramid(PyObject *self, double length, double width, double height, double alpha);
    virtual ~SwigDirector_FormFactorAnisoPyramid();
    virtual FormFactorAnisoPyramid *clone() const;
    virtual void transferToCPP();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      IParameterized::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      FormFactorAnisoPyramid::init_parameters();
    }
    virtual ISample *cloneInvertB() const;
    virtual void accept(ISampleVisitor *visitor) const;
    virtual DWBASimulation *createDWBASimulation() const;
    virtual void printSampleTree();
    virtual bool containsMagneticMaterial() const;
    virtual std::vector< ISample const *,std::allocator< ISample const * > > getChildren() const;
    virtual size_t size() const;
    virtual void setAmbientMaterial(IMaterial const &arg0);
    virtual complex_t evaluate(WavevectorInfo const &wavevectors) const;
    virtual double getVolume() const;
    virtual double getRadius() const;
    virtual void setSpecularInfo(ILayerRTCoefficients const *p_in_coeffs, ILayerRTCoefficients const *p_out_coeffs);
    virtual complex_t evaluate_for_q(cvector_t const &q) const;
    virtual bool check_initialization() const;
    virtual bool check_initializationSwigPublic() const {
      return FormFactorAnisoPyramid::check_initialization();
    }

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class FormFactorAnisoPyramid doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[20];
#endif

};


class SwigDirector_FormFactorBox : public FormFactorBox, public Swig::Director {

public:
    SwigDirector_FormFactorBox(PyObject *self, double length, double width, double height);
    virtual ~SwigDirector_FormFactorBox();
    virtual FormFactorBox *clone() const;
    virtual void transferToCPP();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      IParameterized::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      FormFactorBox::init_parameters();
    }
    virtual ISample *cloneInvertB() const;
    virtual void accept(ISampleVisitor *visitor) const;
    virtual DWBASimulation *createDWBASimulation() const;
    virtual void printSampleTree();
    virtual bool containsMagneticMaterial() const;
    virtual std::vector< ISample const *,std::allocator< ISample const * > > getChildren() const;
    virtual size_t size() const;
    virtual void setAmbientMaterial(IMaterial const &arg0);
    virtual complex_t evaluate(WavevectorInfo const &wavevectors) const;
    virtual double getVolume() const;
    virtual double getRadius() const;
    virtual void setSpecularInfo(ILayerRTCoefficients const *p_in_coeffs, ILayerRTCoefficients const *p_out_coeffs);
    virtual complex_t evaluate_for_q(cvector_t const &q) const;
    virtual bool check_initialization() const;
    virtual bool check_initializationSwigPublic() const {
      return FormFactorBox::check_initialization();
    }

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class FormFactorBox doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[20];
#endif

};


class SwigDirector_FormFactorCone : public FormFactorCone, public Swig::Director {

public:
    SwigDirector_FormFactorCone(PyObject *self, double radius, double height, double alpha);
    virtual ~SwigDirector_FormFactorCone();
    virtual FormFactorCone *clone() const;
    virtual void transferToCPP();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      IParameterized::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      FormFactorCone::init_parameters();
    }
    virtual ISample *cloneInvertB() const;
    virtual void accept(ISampleVisitor *visitor) const;
    virtual DWBASimulation *createDWBASimulation() const;
    virtual void printSampleTree();
    virtual bool containsMagneticMaterial() const;
    virtual std::vector< ISample const *,std::allocator< ISample const * > > getChildren() const;
    virtual size_t size() const;
    virtual void setAmbientMaterial(IMaterial const &arg0);
    virtual complex_t evaluate(WavevectorInfo const &wavevectors) const;
    virtual double getVolume() const;
    virtual double getRadius() const;
    virtual void setSpecularInfo(ILayerRTCoefficients const *p_in_coeffs, ILayerRTCoefficients const *p_out_coeffs);
    virtual complex_t evaluate_for_q(cvector_t const &q) const;
    virtual bool check_initialization() const;
    virtual bool check_initializationSwigPublic() const {
      return FormFactorCone::check_initialization();
    }

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class FormFactorCone doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[20];
#endif

};


class SwigDirector_FormFactorCone6 : public FormFactorCone6, public Swig::Director {

public:
    SwigDirector_FormFactorCone6(PyObject *self, double radius, double height, double alpha);
    virtual ~SwigDirector_FormFactorCone6();
    virtual FormFactorCone6 *clone() const;
    virtual void transferToCPP();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      IParameterized::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      FormFactorCone6::init_parameters();
    }
    virtual ISample *cloneInvertB() const;
    virtual void accept(ISampleVisitor *visitor) const;
    virtual DWBASimulation *createDWBASimulation() const;
    virtual void printSampleTree();
    virtual bool containsMagneticMaterial() const;
    virtual std::vector< ISample const *,std::allocator< ISample const * > > getChildren() const;
    virtual size_t size() const;
    virtual void setAmbientMaterial(IMaterial const &arg0);
    virtual complex_t evaluate(WavevectorInfo const &wavevectors) const;
    virtual double getVolume() const;
    virtual double getRadius() const;
    virtual void setSpecularInfo(ILayerRTCoefficients const *p_in_coeffs, ILayerRTCoefficients const *p_out_coeffs);
    virtual complex_t evaluate_for_q(cvector_t const &q) const;
    virtual bool check_initialization() const;
    virtual bool check_initializationSwigPublic() const {
      return FormFactorCone6::check_initialization();
    }

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class FormFactorCone6 doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[20];
#endif

};


class SwigDirector_FormFactorCrystal : public FormFactorCrystal, public Swig::Director {

public:
    SwigDirector_FormFactorCrystal(PyObject *self, Lattice const &lattice, IFormFactor const &basis_form_factor, IFormFactor const &meso_form_factor);
    virtual ~SwigDirector_FormFactorCrystal();
    virtual FormFactorCrystal *clone() const;
    virtual void transferToCPP();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      IParameterized::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      IParameterized::init_parameters();
    }
    virtual ISample *cloneInvertB() const;
    virtual void accept(ISampleVisitor *visitor) const;
    virtual DWBASimulation *createDWBASimulation() const;
    virtual void printSampleTree();
    virtual bool containsMagneticMaterial() const;
    virtual std::vector< ISample const *,std::allocator< ISample const * > > getChildren() const;
    virtual size_t size() const;
    virtual void setAmbientMaterial(IMaterial const &arg0);
    virtual complex_t evaluate(WavevectorInfo const &wavevectors) const;
    virtual double getVolume() const;
    virtual double getRadius() const;
    virtual void setSpecularInfo(ILayerRTCoefficients const *p_in_coeffs, ILayerRTCoefficients const *p_out_coeffs);
    virtual complex_t evaluate_for_q(cvector_t const &q) const;
    virtual bool check_initialization() const;
    virtual bool check_initializationSwigPublic() const {
      return IFormFactorBorn::check_initialization();
    }

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class FormFactorCrystal doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[20];
#endif

};


class SwigDirector_FormFactorCuboctahedron : public FormFactorCuboctahedron, public Swig::Director {

public:
    SwigDirector_FormFactorCuboctahedron(PyObject *self, double length, double height, double height_ratio, double alpha);
    virtual ~SwigDirector_FormFactorCuboctahedron();
    virtual FormFactorCuboctahedron *clone() const;
    virtual void transferToCPP();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      IParameterized::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      FormFactorCuboctahedron::init_parameters();
    }
    virtual ISample *cloneInvertB() const;
    virtual void accept(ISampleVisitor *visitor) const;
    virtual DWBASimulation *createDWBASimulation() const;
    virtual void printSampleTree();
    virtual bool containsMagneticMaterial() const;
    virtual std::vector< ISample const *,std::allocator< ISample const * > > getChildren() const;
    virtual size_t size() const;
    virtual void setAmbientMaterial(IMaterial const &arg0);
    virtual complex_t evaluate(WavevectorInfo const &wavevectors) const;
    virtual double getVolume() const;
    virtual double getRadius() const;
    virtual void setSpecularInfo(ILayerRTCoefficients const *p_in_coeffs, ILayerRTCoefficients const *p_out_coeffs);
    virtual complex_t evaluate_for_q(cvector_t const &q) const;
    virtual bool check_initialization() const;
    virtual bool check_initializationSwigPublic() const {
      return FormFactorCuboctahedron::check_initialization();
    }

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class FormFactorCuboctahedron doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[20];
#endif

};


class SwigDirector_FormFactorCylinder : public FormFactorCylinder, public Swig::Director {

public:
    SwigDirector_FormFactorCylinder(PyObject *self, double radius, double height);
    virtual ~SwigDirector_FormFactorCylinder();
    virtual FormFactorCylinder *clone() const;
    virtual void transferToCPP();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      IParameterized::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      FormFactorCylinder::init_parameters();
    }
    virtual ISample *cloneInvertB() const;
    virtual void accept(ISampleVisitor *visitor) const;
    virtual DWBASimulation *createDWBASimulation() const;
    virtual void printSampleTree();
    virtual bool containsMagneticMaterial() const;
    virtual std::vector< ISample const *,std::allocator< ISample const * > > getChildren() const;
    virtual size_t size() const;
    virtual void setAmbientMaterial(IMaterial const &arg0);
    virtual complex_t evaluate(WavevectorInfo const &wavevectors) const;
    virtual double getVolume() const;
    virtual double getRadius() const;
    virtual void setSpecularInfo(ILayerRTCoefficients const *p_in_coeffs, ILayerRTCoefficients const *p_out_coeffs);
    virtual complex_t evaluate_for_q(cvector_t const &q) const;
    virtual bool check_initialization() const;
    virtual bool check_initializationSwigPublic() const {
      return FormFactorCylinder::check_initialization();
    }

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class FormFactorCylinder doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[20];
#endif

};


class SwigDirector_FormFactorDecoratorDebyeWaller : public FormFactorDecoratorDebyeWaller, public Swig::Director {

public:
    SwigDirector_FormFactorDecoratorDebyeWaller(PyObject *self, IFormFactor const &form_factor, double dw_factor);
    SwigDirector_FormFactorDecoratorDebyeWaller(PyObject *self, IFormFactor const &form_factor, double dw_h_factor, double dw_r_factor);
    virtual ~SwigDirector_FormFactorDecoratorDebyeWaller();
    virtual FormFactorDecoratorDebyeWaller *clone() const;
    virtual void transferToCPP();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      IParameterized::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      FormFactorDecoratorDebyeWaller::init_parameters();
    }
    virtual ISample *cloneInvertB() const;
    virtual void accept(ISampleVisitor *visitor) const;
    virtual DWBASimulation *createDWBASimulation() const;
    virtual void printSampleTree();
    virtual bool containsMagneticMaterial() const;
    virtual std::vector< ISample const *,std::allocator< ISample const * > > getChildren() const;
    virtual size_t size() const;
    virtual void setAmbientMaterial(IMaterial const &material);
    virtual complex_t evaluate(WavevectorInfo const &wavevectors) const;
    virtual double getVolume() const;
    virtual double getRadius() const;
    virtual void setSpecularInfo(ILayerRTCoefficients const *p_in_coeffs, ILayerRTCoefficients const *p_out_coeffs);
    virtual bool check_initialization() const;
    virtual bool check_initializationSwigPublic() const {
      return FormFactorDecoratorDebyeWaller::check_initialization();
    }

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class FormFactorDecoratorDebyeWaller doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[19];
#endif

};


class SwigDirector_FormFactorEllipsoidalCylinder : public FormFactorEllipsoidalCylinder, public Swig::Director {

public:
    SwigDirector_FormFactorEllipsoidalCylinder(PyObject *self, double radius_x, double radius_y, double height);
    virtual ~SwigDirector_FormFactorEllipsoidalCylinder();
    virtual FormFactorEllipsoidalCylinder *clone() const;
    virtual void transferToCPP();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      IParameterized::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      FormFactorEllipsoidalCylinder::init_parameters();
    }
    virtual ISample *cloneInvertB() const;
    virtual void accept(ISampleVisitor *visitor) const;
    virtual DWBASimulation *createDWBASimulation() const;
    virtual void printSampleTree();
    virtual bool containsMagneticMaterial() const;
    virtual std::vector< ISample const *,std::allocator< ISample const * > > getChildren() const;
    virtual size_t size() const;
    virtual void setAmbientMaterial(IMaterial const &arg0);
    virtual complex_t evaluate(WavevectorInfo const &wavevectors) const;
    virtual double getVolume() const;
    virtual double getRadius() const;
    virtual void setSpecularInfo(ILayerRTCoefficients const *p_in_coeffs, ILayerRTCoefficients const *p_out_coeffs);
    virtual complex_t evaluate_for_q(cvector_t const &q) const;
    virtual bool check_initialization() const;
    virtual bool check_initializationSwigPublic() const {
      return FormFactorEllipsoidalCylinder::check_initialization();
    }

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class FormFactorEllipsoidalCylinder doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[20];
#endif

};


class SwigDirector_FormFactorFullSphere : public FormFactorFullSphere, public Swig::Director {

public:
    SwigDirector_FormFactorFullSphere(PyObject *self, double radius);
    virtual ~SwigDirector_FormFactorFullSphere();
    virtual FormFactorFullSphere *clone() const;
    virtual void transferToCPP();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      IParameterized::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      FormFactorFullSphere::init_parameters();
    }
    virtual ISample *cloneInvertB() const;
    virtual void accept(ISampleVisitor *visitor) const;
    virtual DWBASimulation *createDWBASimulation() const;
    virtual void printSampleTree();
    virtual bool containsMagneticMaterial() const;
    virtual std::vector< ISample const *,std::allocator< ISample const * > > getChildren() const;
    virtual size_t size() const;
    virtual void setAmbientMaterial(IMaterial const &arg0);
    virtual complex_t evaluate(WavevectorInfo const &wavevectors) const;
    virtual double getVolume() const;
    virtual double getRadius() const;
    virtual void setSpecularInfo(ILayerRTCoefficients const *p_in_coeffs, ILayerRTCoefficients const *p_out_coeffs);
    virtual complex_t evaluate_for_q(cvector_t const &q) const;
    virtual bool check_initialization() const;
    virtual bool check_initializationSwigPublic() const {
      return FormFactorFullSphere::check_initialization();
    }

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class FormFactorFullSphere doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[20];
#endif

};


class SwigDirector_FormFactorFullSpheroid : public FormFactorFullSpheroid, public Swig::Director {

public:
    SwigDirector_FormFactorFullSpheroid(PyObject *self, double radius, double height);
    virtual ~SwigDirector_FormFactorFullSpheroid();
    virtual FormFactorFullSpheroid *clone() const;
    virtual void transferToCPP();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      IParameterized::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      FormFactorFullSpheroid::init_parameters();
    }
    virtual ISample *cloneInvertB() const;
    virtual void accept(ISampleVisitor *visitor) const;
    virtual DWBASimulation *createDWBASimulation() const;
    virtual void printSampleTree();
    virtual bool containsMagneticMaterial() const;
    virtual std::vector< ISample const *,std::allocator< ISample const * > > getChildren() const;
    virtual size_t size() const;
    virtual void setAmbientMaterial(IMaterial const &arg0);
    virtual complex_t evaluate(WavevectorInfo const &wavevectors) const;
    virtual double getVolume() const;
    virtual double getRadius() const;
    virtual void setSpecularInfo(ILayerRTCoefficients const *p_in_coeffs, ILayerRTCoefficients const *p_out_coeffs);
    virtual complex_t evaluate_for_q(cvector_t const &q) const;
    virtual bool check_initialization() const;
    virtual bool check_initializationSwigPublic() const {
      return FormFactorFullSpheroid::check_initialization();
    }

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class FormFactorFullSpheroid doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[20];
#endif

};


class SwigDirector_FormFactorGauss : public FormFactorGauss, public Swig::Director {

public:
    SwigDirector_FormFactorGauss(PyObject *self, double volume);
    SwigDirector_FormFactorGauss(PyObject *self, double width, double height);
    virtual ~SwigDirector_FormFactorGauss();
    virtual FormFactorGauss *clone() const;
    virtual void transferToCPP();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      IParameterized::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      FormFactorGauss::init_parameters();
    }
    virtual ISample *cloneInvertB() const;
    virtual void accept(ISampleVisitor *visitor) const;
    virtual DWBASimulation *createDWBASimulation() const;
    virtual void printSampleTree();
    virtual bool containsMagneticMaterial() const;
    virtual std::vector< ISample const *,std::allocator< ISample const * > > getChildren() const;
    virtual size_t size() const;
    virtual void setAmbientMaterial(IMaterial const &arg0);
    virtual complex_t evaluate(WavevectorInfo const &wavevectors) const;
    virtual double getVolume() const;
    virtual double getRadius() const;
    virtual void setSpecularInfo(ILayerRTCoefficients const *p_in_coeffs, ILayerRTCoefficients const *p_out_coeffs);
    virtual complex_t evaluate_for_q(cvector_t const &q) const;
    virtual bool check_initialization() const;
    virtual bool check_initializationSwigPublic() const {
      return FormFactorGauss::check_initialization();
    }

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class FormFactorGauss doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[20];
#endif

};


class SwigDirector_FormFactorHemiEllipsoid : public FormFactorHemiEllipsoid, public Swig::Director {

public:
    SwigDirector_FormFactorHemiEllipsoid(PyObject *self, double radius_x, double radius_y, double height);
    virtual ~SwigDirector_FormFactorHemiEllipsoid();
    virtual FormFactorHemiEllipsoid *clone() const;
    virtual void transferToCPP();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      IParameterized::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      FormFactorHemiEllipsoid::init_parameters();
    }
    virtual ISample *cloneInvertB() const;
    virtual void accept(ISampleVisitor *visitor) const;
    virtual DWBASimulation *createDWBASimulation() const;
    virtual void printSampleTree();
    virtual bool containsMagneticMaterial() const;
    virtual std::vector< ISample const *,std::allocator< ISample const * > > getChildren() const;
    virtual size_t size() const;
    virtual void setAmbientMaterial(IMaterial const &arg0);
    virtual complex_t evaluate(WavevectorInfo const &wavevectors) const;
    virtual double getVolume() const;
    virtual double getRadius() const;
    virtual void setSpecularInfo(ILayerRTCoefficients const *p_in_coeffs, ILayerRTCoefficients const *p_out_coeffs);
    virtual complex_t evaluate_for_q(cvector_t const &q) const;
    virtual bool check_initialization() const;
    virtual bool check_initializationSwigPublic() const {
      return FormFactorHemiEllipsoid::check_initialization();
    }

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class FormFactorHemiEllipsoid doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[20];
#endif

};


class SwigDirector_FormFactorLorentz : public FormFactorLorentz, public Swig::Director {

public:
    SwigDirector_FormFactorLorentz(PyObject *self, double volume);
    SwigDirector_FormFactorLorentz(PyObject *self, double width, double height);
    virtual ~SwigDirector_FormFactorLorentz();
    virtual FormFactorLorentz *clone() const;
    virtual void transferToCPP();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      IParameterized::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      FormFactorLorentz::init_parameters();
    }
    virtual ISample *cloneInvertB() const;
    virtual void accept(ISampleVisitor *visitor) const;
    virtual DWBASimulation *createDWBASimulation() const;
    virtual void printSampleTree();
    virtual bool containsMagneticMaterial() const;
    virtual std::vector< ISample const *,std::allocator< ISample const * > > getChildren() const;
    virtual size_t size() const;
    virtual void setAmbientMaterial(IMaterial const &arg0);
    virtual complex_t evaluate(WavevectorInfo const &wavevectors) const;
    virtual double getVolume() const;
    virtual double getRadius() const;
    virtual void setSpecularInfo(ILayerRTCoefficients const *p_in_coeffs, ILayerRTCoefficients const *p_out_coeffs);
    virtual complex_t evaluate_for_q(cvector_t const &q) const;
    virtual bool check_initialization() const;
    virtual bool check_initializationSwigPublic() const {
      return FormFactorLorentz::check_initialization();
    }

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class FormFactorLorentz doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[20];
#endif

};


class SwigDirector_FormFactorPrism3 : public FormFactorPrism3, public Swig::Director {

public:
    SwigDirector_FormFactorPrism3(PyObject *self, double length, double height);
    virtual ~SwigDirector_FormFactorPrism3();
    virtual FormFactorPrism3 *clone() const;
    virtual void transferToCPP();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      IParameterized::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      FormFactorPrism3::init_parameters();
    }
    virtual ISample *cloneInvertB() const;
    virtual void accept(ISampleVisitor *visitor) const;
    virtual DWBASimulation *createDWBASimulation() const;
    virtual void printSampleTree();
    virtual bool containsMagneticMaterial() const;
    virtual std::vector< ISample const *,std::allocator< ISample const * > > getChildren() const;
    virtual size_t size() const;
    virtual void setAmbientMaterial(IMaterial const &arg0);
    virtual complex_t evaluate(WavevectorInfo const &wavevectors) const;
    virtual double getVolume() const;
    virtual double getRadius() const;
    virtual void setSpecularInfo(ILayerRTCoefficients const *p_in_coeffs, ILayerRTCoefficients const *p_out_coeffs);
    virtual complex_t evaluate_for_q(cvector_t const &q) const;
    virtual bool check_initialization() const;
    virtual bool check_initializationSwigPublic() const {
      return FormFactorPrism3::check_initialization();
    }

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class FormFactorPrism3 doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[20];
#endif

};


class SwigDirector_FormFactorPrism6 : public FormFactorPrism6, public Swig::Director {

public:
    SwigDirector_FormFactorPrism6(PyObject *self, double radius, double height);
    virtual ~SwigDirector_FormFactorPrism6();
    virtual FormFactorPrism6 *clone() const;
    virtual void transferToCPP();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      IParameterized::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      FormFactorPrism6::init_parameters();
    }
    virtual ISample *cloneInvertB() const;
    virtual void accept(ISampleVisitor *visitor) const;
    virtual DWBASimulation *createDWBASimulation() const;
    virtual void printSampleTree();
    virtual bool containsMagneticMaterial() const;
    virtual std::vector< ISample const *,std::allocator< ISample const * > > getChildren() const;
    virtual size_t size() const;
    virtual void setAmbientMaterial(IMaterial const &arg0);
    virtual complex_t evaluate(WavevectorInfo const &wavevectors) const;
    virtual double getVolume() const;
    virtual double getRadius() const;
    virtual void setSpecularInfo(ILayerRTCoefficients const *p_in_coeffs, ILayerRTCoefficients const *p_out_coeffs);
    virtual complex_t evaluate_for_q(cvector_t const &q) const;
    virtual bool check_initialization() const;
    virtual bool check_initializationSwigPublic() const {
      return FormFactorPrism6::check_initialization();
    }

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class FormFactorPrism6 doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[20];
#endif

};


class SwigDirector_FormFactorPyramid : public FormFactorPyramid, public Swig::Director {

public:
    SwigDirector_FormFactorPyramid(PyObject *self, double length, double height, double alpha);
    virtual ~SwigDirector_FormFactorPyramid();
    virtual FormFactorPyramid *clone() const;
    virtual void transferToCPP();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      IParameterized::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      FormFactorPyramid::init_parameters();
    }
    virtual ISample *cloneInvertB() const;
    virtual void accept(ISampleVisitor *visitor) const;
    virtual DWBASimulation *createDWBASimulation() const;
    virtual void printSampleTree();
    virtual bool containsMagneticMaterial() const;
    virtual std::vector< ISample const *,std::allocator< ISample const * > > getChildren() const;
    virtual size_t size() const;
    virtual void setAmbientMaterial(IMaterial const &arg0);
    virtual complex_t evaluate(WavevectorInfo const &wavevectors) const;
    virtual double getVolume() const;
    virtual double getRadius() const;
    virtual void setSpecularInfo(ILayerRTCoefficients const *p_in_coeffs, ILayerRTCoefficients const *p_out_coeffs);
    virtual complex_t evaluate_for_q(cvector_t const &q) const;
    virtual bool check_initialization() const;
    virtual bool check_initializationSwigPublic() const {
      return FormFactorPyramid::check_initialization();
    }

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class FormFactorPyramid doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[20];
#endif

};


class SwigDirector_FormFactorRipple1 : public FormFactorRipple1, public Swig::Director {

public:
    SwigDirector_FormFactorRipple1(PyObject *self, double length, double width, double height);
    virtual ~SwigDirector_FormFactorRipple1();
    virtual FormFactorRipple1 *clone() const;
    virtual void transferToCPP();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      IParameterized::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      FormFactorRipple1::init_parameters();
    }
    virtual ISample *cloneInvertB() const;
    virtual void accept(ISampleVisitor *visitor) const;
    virtual DWBASimulation *createDWBASimulation() const;
    virtual void printSampleTree();
    virtual bool containsMagneticMaterial() const;
    virtual std::vector< ISample const *,std::allocator< ISample const * > > getChildren() const;
    virtual size_t size() const;
    virtual void setAmbientMaterial(IMaterial const &arg0);
    virtual complex_t evaluate(WavevectorInfo const &wavevectors) const;
    virtual double getVolume() const;
    virtual double getRadius() const;
    virtual void setSpecularInfo(ILayerRTCoefficients const *p_in_coeffs, ILayerRTCoefficients const *p_out_coeffs);
    virtual complex_t evaluate_for_q(cvector_t const &q) const;
    virtual bool check_initialization() const;
    virtual bool check_initializationSwigPublic() const {
      return FormFactorRipple1::check_initialization();
    }

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class FormFactorRipple1 doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[20];
#endif

};


class SwigDirector_FormFactorRipple2 : public FormFactorRipple2, public Swig::Director {

public:
    SwigDirector_FormFactorRipple2(PyObject *self, double length, double width, double height, double asymetry);
    virtual ~SwigDirector_FormFactorRipple2();
    virtual FormFactorRipple2 *clone() const;
    virtual void transferToCPP();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      IParameterized::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      FormFactorRipple2::init_parameters();
    }
    virtual ISample *cloneInvertB() const;
    virtual void accept(ISampleVisitor *visitor) const;
    virtual DWBASimulation *createDWBASimulation() const;
    virtual void printSampleTree();
    virtual bool containsMagneticMaterial() const;
    virtual std::vector< ISample const *,std::allocator< ISample const * > > getChildren() const;
    virtual size_t size() const;
    virtual void setAmbientMaterial(IMaterial const &arg0);
    virtual complex_t evaluate(WavevectorInfo const &wavevectors) const;
    virtual double getVolume() const;
    virtual double getRadius() const;
    virtual void setSpecularInfo(ILayerRTCoefficients const *p_in_coeffs, ILayerRTCoefficients const *p_out_coeffs);
    virtual complex_t evaluate_for_q(cvector_t const &q) const;
    virtual bool check_initialization() const;
    virtual bool check_initializationSwigPublic() const {
      return FormFactorRipple2::check_initialization();
    }

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class FormFactorRipple2 doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[20];
#endif

};


class SwigDirector_FormFactorSphereGaussianRadius : public FormFactorSphereGaussianRadius, public Swig::Director {

public:
    SwigDirector_FormFactorSphereGaussianRadius(PyObject *self, double mean, double sigma);
    virtual ~SwigDirector_FormFactorSphereGaussianRadius();
    virtual FormFactorSphereGaussianRadius *clone() const;
    virtual void transferToCPP();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      IParameterized::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      FormFactorSphereGaussianRadius::init_parameters();
    }
    virtual ISample *cloneInvertB() const;
    virtual void accept(ISampleVisitor *visitor) const;
    virtual DWBASimulation *createDWBASimulation() const;
    virtual void printSampleTree();
    virtual bool containsMagneticMaterial() const;
    virtual std::vector< ISample const *,std::allocator< ISample const * > > getChildren() const;
    virtual size_t size() const;
    virtual void setAmbientMaterial(IMaterial const &arg0);
    virtual complex_t evaluate(WavevectorInfo const &wavevectors) const;
    virtual double getVolume() const;
    virtual double getRadius() const;
    virtual void setSpecularInfo(ILayerRTCoefficients const *p_in_coeffs, ILayerRTCoefficients const *p_out_coeffs);
    virtual complex_t evaluate_for_q(cvector_t const &q) const;
    virtual bool check_initialization() const;
    virtual bool check_initializationSwigPublic() const {
      return FormFactorSphereGaussianRadius::check_initialization();
    }

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class FormFactorSphereGaussianRadius doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[20];
#endif

};


class SwigDirector_FormFactorSphereLogNormalRadius : public FormFactorSphereLogNormalRadius, public Swig::Director {

public:
    SwigDirector_FormFactorSphereLogNormalRadius(PyObject *self, double mean, double scale_param, size_t n_samples);
    virtual ~SwigDirector_FormFactorSphereLogNormalRadius();
    virtual FormFactorSphereLogNormalRadius *clone() const;
    virtual void transferToCPP();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      IParameterized::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      FormFactorSphereLogNormalRadius::init_parameters();
    }
    virtual ISample *cloneInvertB() const;
    virtual void accept(ISampleVisitor *visitor) const;
    virtual DWBASimulation *createDWBASimulation() const;
    virtual void printSampleTree();
    virtual bool containsMagneticMaterial() const;
    virtual std::vector< ISample const *,std::allocator< ISample const * > > getChildren() const;
    virtual size_t size() const;
    virtual void setAmbientMaterial(IMaterial const &arg0);
    virtual complex_t evaluate(WavevectorInfo const &wavevectors) const;
    virtual double getVolume() const;
    virtual double getRadius() const;
    virtual void setSpecularInfo(ILayerRTCoefficients const *p_in_coeffs, ILayerRTCoefficients const *p_out_coeffs);
    virtual complex_t evaluate_for_q(cvector_t const &q) const;
    virtual bool check_initialization() const;
    virtual bool check_initializationSwigPublic() const {
      return FormFactorSphereLogNormalRadius::check_initialization();
    }

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class FormFactorSphereLogNormalRadius doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[20];
#endif

};


class SwigDirector_FormFactorSphereUniformRadius : public FormFactorSphereUniformRadius, public Swig::Director {

public:
    SwigDirector_FormFactorSphereUniformRadius(PyObject *self, double mean, double full_width);
    virtual ~SwigDirector_FormFactorSphereUniformRadius();
    virtual FormFactorSphereUniformRadius *clone() const;
    virtual void transferToCPP();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      IParameterized::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      FormFactorSphereUniformRadius::init_parameters();
    }
    virtual ISample *cloneInvertB() const;
    virtual void accept(ISampleVisitor *visitor) const;
    virtual DWBASimulation *createDWBASimulation() const;
    virtual void printSampleTree();
    virtual bool containsMagneticMaterial() const;
    virtual std::vector< ISample const *,std::allocator< ISample const * > > getChildren() const;
    virtual size_t size() const;
    virtual void setAmbientMaterial(IMaterial const &arg0);
    virtual complex_t evaluate(WavevectorInfo const &wavevectors) const;
    virtual double getVolume() const;
    virtual double getRadius() const;
    virtual void setSpecularInfo(ILayerRTCoefficients const *p_in_coeffs, ILayerRTCoefficients const *p_out_coeffs);
    virtual complex_t evaluate_for_q(cvector_t const &q) const;
    virtual bool check_initialization() const;
    virtual bool check_initializationSwigPublic() const {
      return FormFactorSphereUniformRadius::check_initialization();
    }

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class FormFactorSphereUniformRadius doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[20];
#endif

};


class SwigDirector_FormFactorTetrahedron : public FormFactorTetrahedron, public Swig::Director {

public:
    SwigDirector_FormFactorTetrahedron(PyObject *self, double length, double height, double alpha);
    virtual ~SwigDirector_FormFactorTetrahedron();
    virtual FormFactorTetrahedron *clone() const;
    virtual void transferToCPP();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      IParameterized::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      FormFactorTetrahedron::init_parameters();
    }
    virtual ISample *cloneInvertB() const;
    virtual void accept(ISampleVisitor *visitor) const;
    virtual DWBASimulation *createDWBASimulation() const;
    virtual void printSampleTree();
    virtual bool containsMagneticMaterial() const;
    virtual std::vector< ISample const *,std::allocator< ISample const * > > getChildren() const;
    virtual size_t size() const;
    virtual void setAmbientMaterial(IMaterial const &arg0);
    virtual complex_t evaluate(WavevectorInfo const &wavevectors) const;
    virtual double getVolume() const;
    virtual double getRadius() const;
    virtual void setSpecularInfo(ILayerRTCoefficients const *p_in_coeffs, ILayerRTCoefficients const *p_out_coeffs);
    virtual complex_t evaluate_for_q(cvector_t const &q) const;
    virtual bool check_initialization() const;
    virtual bool check_initializationSwigPublic() const {
      return FormFactorTetrahedron::check_initialization();
    }

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class FormFactorTetrahedron doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[20];
#endif

};


class SwigDirector_FormFactorTrivial : public FormFactorTrivial, public Swig::Director {

public:
    SwigDirector_FormFactorTrivial(PyObject *self);
    virtual ~SwigDirector_FormFactorTrivial();
    virtual FormFactorTrivial *clone() const;
    virtual void transferToCPP();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      IParameterized::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      FormFactorTrivial::init_parameters();
    }
    virtual ISample *cloneInvertB() const;
    virtual void accept(ISampleVisitor *visitor) const;
    virtual DWBASimulation *createDWBASimulation() const;
    virtual void printSampleTree();
    virtual bool containsMagneticMaterial() const;
    virtual std::vector< ISample const *,std::allocator< ISample const * > > getChildren() const;
    virtual size_t size() const;
    virtual void setAmbientMaterial(IMaterial const &arg0);
    virtual complex_t evaluate(WavevectorInfo const &wavevectors) const;
    virtual double getVolume() const;
    virtual double getRadius() const;
    virtual void setSpecularInfo(ILayerRTCoefficients const *p_in_coeffs, ILayerRTCoefficients const *p_out_coeffs);
    virtual complex_t evaluate_for_q(cvector_t const &q) const;
    virtual bool check_initialization() const;
    virtual bool check_initializationSwigPublic() const {
      return FormFactorTrivial::check_initialization();
    }

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class FormFactorTrivial doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[20];
#endif

};


class SwigDirector_FormFactorTruncatedCube : public FormFactorTruncatedCube, public Swig::Director {

public:
    SwigDirector_FormFactorTruncatedCube(PyObject *self, double length, double removed_length);
    virtual ~SwigDirector_FormFactorTruncatedCube();
    virtual FormFactorTruncatedCube *clone() const;
    virtual void transferToCPP();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      IParameterized::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      FormFactorTruncatedCube::init_parameters();
    }
    virtual ISample *cloneInvertB() const;
    virtual void accept(ISampleVisitor *visitor) const;
    virtual DWBASimulation *createDWBASimulation() const;
    virtual void printSampleTree();
    virtual bool containsMagneticMaterial() const;
    virtual std::vector< ISample const *,std::allocator< ISample const * > > getChildren() const;
    virtual size_t size() const;
    virtual void setAmbientMaterial(IMaterial const &arg0);
    virtual complex_t evaluate(WavevectorInfo const &wavevectors) const;
    virtual double getVolume() const;
    virtual double getRadius() const;
    virtual void setSpecularInfo(ILayerRTCoefficients const *p_in_coeffs, ILayerRTCoefficients const *p_out_coeffs);
    virtual complex_t evaluate_for_q(cvector_t const &q) const;
    virtual complex_t evaluate_for_qSwigPublic(cvector_t const &q) const {
      return FormFactorTruncatedCube::evaluate_for_q(q);
    }
    virtual bool check_initialization() const;
    virtual bool check_initializationSwigPublic() const {
      return FormFactorTruncatedCube::check_initialization();
    }

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class FormFactorTruncatedCube doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[20];
#endif

};


class SwigDirector_FormFactorTruncatedSphere : public FormFactorTruncatedSphere, public Swig::Director {

public:
    SwigDirector_FormFactorTruncatedSphere(PyObject *self, double radius, double height);
    virtual ~SwigDirector_FormFactorTruncatedSphere();
    virtual FormFactorTruncatedSphere *clone() const;
    virtual void transferToCPP();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      IParameterized::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      FormFactorTruncatedSphere::init_parameters();
    }
    virtual ISample *cloneInvertB() const;
    virtual void accept(ISampleVisitor *visitor) const;
    virtual DWBASimulation *createDWBASimulation() const;
    virtual void printSampleTree();
    virtual bool containsMagneticMaterial() const;
    virtual std::vector< ISample const *,std::allocator< ISample const * > > getChildren() const;
    virtual size_t size() const;
    virtual void setAmbientMaterial(IMaterial const &arg0);
    virtual complex_t evaluate(WavevectorInfo const &wavevectors) const;
    virtual double getVolume() const;
    virtual double getRadius() const;
    virtual void setSpecularInfo(ILayerRTCoefficients const *p_in_coeffs, ILayerRTCoefficients const *p_out_coeffs);
    virtual complex_t evaluate_for_q(cvector_t const &q) const;
    virtual complex_t evaluate_for_qSwigPublic(cvector_t const &q) const {
      return FormFactorTruncatedSphere::evaluate_for_q(q);
    }
    virtual bool check_initialization() const;
    virtual bool check_initializationSwigPublic() const {
      return FormFactorTruncatedSphere::check_initialization();
    }

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class FormFactorTruncatedSphere doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[20];
#endif

};


class SwigDirector_FormFactorTruncatedSpheroid : public FormFactorTruncatedSpheroid, public Swig::Director {

public:
    SwigDirector_FormFactorTruncatedSpheroid(PyObject *self, double radius, double height, double height_flattening);
    virtual ~SwigDirector_FormFactorTruncatedSpheroid();
    virtual FormFactorTruncatedSpheroid *clone() const;
    virtual void transferToCPP();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      IParameterized::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      FormFactorTruncatedSpheroid::init_parameters();
    }
    virtual ISample *cloneInvertB() const;
    virtual void accept(ISampleVisitor *visitor) const;
    virtual DWBASimulation *createDWBASimulation() const;
    virtual void printSampleTree();
    virtual bool containsMagneticMaterial() const;
    virtual std::vector< ISample const *,std::allocator< ISample const * > > getChildren() const;
    virtual size_t size() const;
    virtual void setAmbientMaterial(IMaterial const &arg0);
    virtual complex_t evaluate(WavevectorInfo const &wavevectors) const;
    virtual double getVolume() const;
    virtual double getRadius() const;
    virtual void setSpecularInfo(ILayerRTCoefficients const *p_in_coeffs, ILayerRTCoefficients const *p_out_coeffs);
    virtual complex_t evaluate_for_q(cvector_t const &q) const;
    virtual bool check_initialization() const;
    virtual bool check_initializationSwigPublic() const {
      return FormFactorTruncatedSpheroid::check_initialization();
    }

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class FormFactorTruncatedSpheroid doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[20];
#endif

};


class SwigDirector_FormFactorWeighted : public FormFactorWeighted, public Swig::Director {

public:
    SwigDirector_FormFactorWeighted(PyObject *self);
    virtual ~SwigDirector_FormFactorWeighted();
    virtual FormFactorWeighted *clone() const;
    virtual void transferToCPP();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      IParameterized::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      IParameterized::init_parameters();
    }
    virtual ISample *cloneInvertB() const;
    virtual void accept(ISampleVisitor *visitor) const;
    virtual DWBASimulation *createDWBASimulation() const;
    virtual void printSampleTree();
    virtual bool containsMagneticMaterial() const;
    virtual std::vector< ISample const *,std::allocator< ISample const * > > getChildren() const;
    virtual size_t size() const;
    virtual void setAmbientMaterial(IMaterial const &material);
    virtual complex_t evaluate(WavevectorInfo const &wavevectors) const;
    virtual double getVolume() const;
    virtual double getRadius() const;
    virtual void setSpecularInfo(ILayerRTCoefficients const *p_in_coeffs, ILayerRTCoefficients const *p_out_coeffs);

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class FormFactorWeighted doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[18];
#endif

};


class SwigDirector_IFTDistribution1D : public IFTDistribution1D, public Swig::Director {

public:
    SwigDirector_IFTDistribution1D(PyObject *self, double omega);
    virtual ~SwigDirector_IFTDistribution1D();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      IFTDistribution1D::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      IFTDistribution1D::init_parameters();
    }
    virtual IFTDistribution1D *clone() const;
    virtual double evaluate(double q) const;

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class IFTDistribution1D doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[6];
#endif

};


class SwigDirector_FTDistribution1DCauchy : public FTDistribution1DCauchy, public Swig::Director {

public:
    SwigDirector_FTDistribution1DCauchy(PyObject *self, double omega);
    virtual ~SwigDirector_FTDistribution1DCauchy();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      IFTDistribution1D::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      IFTDistribution1D::init_parameters();
    }
    virtual FTDistribution1DCauchy *clone() const;
    virtual double evaluate(double q) const;

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class FTDistribution1DCauchy doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[6];
#endif

};


class SwigDirector_FTDistribution1DGauss : public FTDistribution1DGauss, public Swig::Director {

public:
    SwigDirector_FTDistribution1DGauss(PyObject *self, double omega);
    virtual ~SwigDirector_FTDistribution1DGauss();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      IFTDistribution1D::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      IFTDistribution1D::init_parameters();
    }
    virtual FTDistribution1DGauss *clone() const;
    virtual double evaluate(double q) const;

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class FTDistribution1DGauss doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[6];
#endif

};


class SwigDirector_FTDistribution1DGate : public FTDistribution1DGate, public Swig::Director {

public:
    SwigDirector_FTDistribution1DGate(PyObject *self, double omega);
    virtual ~SwigDirector_FTDistribution1DGate();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      IFTDistribution1D::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      IFTDistribution1D::init_parameters();
    }
    virtual FTDistribution1DGate *clone() const;
    virtual double evaluate(double q) const;

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class FTDistribution1DGate doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[6];
#endif

};


class SwigDirector_FTDistribution1DTriangle : public FTDistribution1DTriangle, public Swig::Director {

public:
    SwigDirector_FTDistribution1DTriangle(PyObject *self, double omega);
    virtual ~SwigDirector_FTDistribution1DTriangle();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      IFTDistribution1D::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      IFTDistribution1D::init_parameters();
    }
    virtual FTDistribution1DTriangle *clone() const;
    virtual double evaluate(double q) const;

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class FTDistribution1DTriangle doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[6];
#endif

};


class SwigDirector_FTDistribution1DCosine : public FTDistribution1DCosine, public Swig::Director {

public:
    SwigDirector_FTDistribution1DCosine(PyObject *self, double omega);
    virtual ~SwigDirector_FTDistribution1DCosine();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      IFTDistribution1D::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      IFTDistribution1D::init_parameters();
    }
    virtual FTDistribution1DCosine *clone() const;
    virtual double evaluate(double q) const;

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class FTDistribution1DCosine doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[6];
#endif

};


class SwigDirector_FTDistribution1DVoigt : public FTDistribution1DVoigt, public Swig::Director {

public:
    SwigDirector_FTDistribution1DVoigt(PyObject *self, double omega, double eta);
    virtual ~SwigDirector_FTDistribution1DVoigt();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      IFTDistribution1D::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      FTDistribution1DVoigt::init_parameters();
    }
    virtual FTDistribution1DVoigt *clone() const;
    virtual double evaluate(double q) const;
    virtual double getEta() const;

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class FTDistribution1DVoigt doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[7];
#endif

};


class SwigDirector_IFTDistribution2D : public IFTDistribution2D, public Swig::Director {

public:
    SwigDirector_IFTDistribution2D(PyObject *self, double coherence_length_x, double coherence_length_y);
    virtual ~SwigDirector_IFTDistribution2D();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      IFTDistribution2D::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      IFTDistribution2D::init_parameters();
    }
    virtual IFTDistribution2D *clone() const;
    virtual double evaluate(double qx, double qy) const;

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class IFTDistribution2D doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[6];
#endif

};


class SwigDirector_FTDistribution2DCauchy : public FTDistribution2DCauchy, public Swig::Director {

public:
    SwigDirector_FTDistribution2DCauchy(PyObject *self, double coherence_length_x, double coherence_length_y);
    virtual ~SwigDirector_FTDistribution2DCauchy();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      IFTDistribution2D::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      IFTDistribution2D::init_parameters();
    }
    virtual FTDistribution2DCauchy *clone() const;
    virtual double evaluate(double qx, double qy) const;

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class FTDistribution2DCauchy doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[6];
#endif

};


class SwigDirector_FTDistribution2DGauss : public FTDistribution2DGauss, public Swig::Director {

public:
    SwigDirector_FTDistribution2DGauss(PyObject *self, double coherence_length_x, double coherence_length_y);
    virtual ~SwigDirector_FTDistribution2DGauss();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      IFTDistribution2D::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      IFTDistribution2D::init_parameters();
    }
    virtual FTDistribution2DGauss *clone() const;
    virtual double evaluate(double qx, double qy) const;

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class FTDistribution2DGauss doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[6];
#endif

};


class SwigDirector_FTDistribution2DGate : public FTDistribution2DGate, public Swig::Director {

public:
    SwigDirector_FTDistribution2DGate(PyObject *self, double coherence_length_x, double coherence_length_y);
    virtual ~SwigDirector_FTDistribution2DGate();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      IFTDistribution2D::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      IFTDistribution2D::init_parameters();
    }
    virtual FTDistribution2DGate *clone() const;
    virtual double evaluate(double qx, double qy) const;

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class FTDistribution2DGate doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[6];
#endif

};


class SwigDirector_FTDistribution2DCone : public FTDistribution2DCone, public Swig::Director {

public:
    SwigDirector_FTDistribution2DCone(PyObject *self, double coherence_length_x, double coherence_length_y);
    virtual ~SwigDirector_FTDistribution2DCone();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      IFTDistribution2D::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      IFTDistribution2D::init_parameters();
    }
    virtual FTDistribution2DCone *clone() const;
    virtual double evaluate(double qx, double qy) const;

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class FTDistribution2DCone doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[6];
#endif

};


class SwigDirector_FTDistribution2DVoigt : public FTDistribution2DVoigt, public Swig::Director {

public:
    SwigDirector_FTDistribution2DVoigt(PyObject *self, double coherence_length_x, double coherence_length_y, double eta);
    virtual ~SwigDirector_FTDistribution2DVoigt();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      IFTDistribution2D::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      FTDistribution2DVoigt::init_parameters();
    }
    virtual FTDistribution2DVoigt *clone() const;
    virtual double evaluate(double qx, double qy) const;
    virtual double getEta() const;

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class FTDistribution2DVoigt doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[7];
#endif

};


class SwigDirector_IFTDecayFunction1D : public IFTDecayFunction1D, public Swig::Director {

public:
    SwigDirector_IFTDecayFunction1D(PyObject *self, double omega);
    virtual ~SwigDirector_IFTDecayFunction1D();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      IFTDecayFunction1D::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      IFTDecayFunction1D::init_parameters();
    }
    virtual IFTDecayFunction1D *clone() const;
    virtual double evaluate(double q) const;

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class IFTDecayFunction1D doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[6];
#endif

};


class SwigDirector_FTDecayFunction1DCauchy : public FTDecayFunction1DCauchy, public Swig::Director {

public:
    SwigDirector_FTDecayFunction1DCauchy(PyObject *self, double omega);
    virtual ~SwigDirector_FTDecayFunction1DCauchy();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      IFTDecayFunction1D::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      IFTDecayFunction1D::init_parameters();
    }
    virtual FTDecayFunction1DCauchy *clone() const;
    virtual double evaluate(double q) const;

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class FTDecayFunction1DCauchy doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[6];
#endif

};


class SwigDirector_FTDecayFunction1DGauss : public FTDecayFunction1DGauss, public Swig::Director {

public:
    SwigDirector_FTDecayFunction1DGauss(PyObject *self, double omega);
    virtual ~SwigDirector_FTDecayFunction1DGauss();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      IFTDecayFunction1D::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      IFTDecayFunction1D::init_parameters();
    }
    virtual FTDecayFunction1DGauss *clone() const;
    virtual double evaluate(double q) const;

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class FTDecayFunction1DGauss doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[6];
#endif

};


class SwigDirector_FTDecayFunction1DTriangle : public FTDecayFunction1DTriangle, public Swig::Director {

public:
    SwigDirector_FTDecayFunction1DTriangle(PyObject *self, double omega);
    virtual ~SwigDirector_FTDecayFunction1DTriangle();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      IFTDecayFunction1D::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      IFTDecayFunction1D::init_parameters();
    }
    virtual FTDecayFunction1DTriangle *clone() const;
    virtual double evaluate(double q) const;

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class FTDecayFunction1DTriangle doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[6];
#endif

};


class SwigDirector_FTDecayFunction1DVoigt : public FTDecayFunction1DVoigt, public Swig::Director {

public:
    SwigDirector_FTDecayFunction1DVoigt(PyObject *self, double omega, double eta);
    virtual ~SwigDirector_FTDecayFunction1DVoigt();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      IFTDecayFunction1D::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      FTDecayFunction1DVoigt::init_parameters();
    }
    virtual FTDecayFunction1DVoigt *clone() const;
    virtual double evaluate(double q) const;
    virtual double getEta() const;

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class FTDecayFunction1DVoigt doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[7];
#endif

};


class SwigDirector_IFTDecayFunction2D : public IFTDecayFunction2D, public Swig::Director {

public:
    SwigDirector_IFTDecayFunction2D(PyObject *self, double decay_length_x, double decay_length_y);
    virtual ~SwigDirector_IFTDecayFunction2D();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      IFTDecayFunction2D::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      IFTDecayFunction2D::init_parameters();
    }
    virtual IFTDecayFunction2D *clone() const;
    virtual double evaluate(double qx, double qy) const;

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class IFTDecayFunction2D doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[6];
#endif

};


class SwigDirector_FTDecayFunction2DCauchy : public FTDecayFunction2DCauchy, public Swig::Director {

public:
    SwigDirector_FTDecayFunction2DCauchy(PyObject *self, double decay_length_x, double decay_length_y);
    virtual ~SwigDirector_FTDecayFunction2DCauchy();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      IFTDecayFunction2D::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      IFTDecayFunction2D::init_parameters();
    }
    virtual FTDecayFunction2DCauchy *clone() const;
    virtual double evaluate(double qx, double qy) const;

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class FTDecayFunction2DCauchy doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[6];
#endif

};


class SwigDirector_FTDecayFunction2DGauss : public FTDecayFunction2DGauss, public Swig::Director {

public:
    SwigDirector_FTDecayFunction2DGauss(PyObject *self, double decay_length_x, double decay_length_y);
    virtual ~SwigDirector_FTDecayFunction2DGauss();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      IFTDecayFunction2D::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      IFTDecayFunction2D::init_parameters();
    }
    virtual FTDecayFunction2DGauss *clone() const;
    virtual double evaluate(double qx, double qy) const;

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class FTDecayFunction2DGauss doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[6];
#endif

};


class SwigDirector_FTDecayFunction2DVoigt : public FTDecayFunction2DVoigt, public Swig::Director {

public:
    SwigDirector_FTDecayFunction2DVoigt(PyObject *self, double decay_length_x, double decay_length_y, double eta);
    virtual ~SwigDirector_FTDecayFunction2DVoigt();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      IFTDecayFunction2D::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      FTDecayFunction2DVoigt::init_parameters();
    }
    virtual FTDecayFunction2DVoigt *clone() const;
    virtual double evaluate(double qx, double qy) const;
    virtual double getEta() const;

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class FTDecayFunction2DVoigt doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[7];
#endif

};


class SwigDirector_IMaterial : public IMaterial, public Swig::Director {

public:
    SwigDirector_IMaterial(PyObject *self, std::string const &name);
    virtual ~SwigDirector_IMaterial();
    virtual IMaterial *clone() const;
    virtual bool isScalarMaterial() const;
    virtual complex_t getRefractiveIndex() const;
    virtual IMaterial const *createTransformedMaterial(IRotation const &rotation) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      IMaterial::print(ostr);
    }

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class IMaterial doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[5];
#endif

};


class SwigDirector_Simulation : public Simulation, public Swig::Director {

public:
    SwigDirector_Simulation(PyObject *self);
    SwigDirector_Simulation(PyObject *self, ProgramOptions const *p_options);
    SwigDirector_Simulation(PyObject *self, ISample const &p_sample, ProgramOptions const *p_options = 0);
    SwigDirector_Simulation(PyObject *self, SampleBuilder_t p_sample_builder, ProgramOptions const *p_options = 0);
    SwigDirector_Simulation(PyObject *self, Simulation const &other);
    virtual ~SwigDirector_Simulation();
    virtual Simulation *clone() const;
    virtual void transferToCPP();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      IParameterized::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      Simulation::init_parameters();
    }
    virtual void prepareSimulation();
    virtual int getNumberOfSimulationElements() const;
    virtual OutputData< double > *getDetectorIntensity(IDetector2D::EAxesUnits units_type = IDetector2D::DEFAULT) const;
    virtual void initSimulationElementVector();
    virtual void transferResultsToIntensityMap();
    virtual double getBeamIntensity() const;

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class Simulation doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[13];
#endif

};


class SwigDirector_GISASSimulation : public GISASSimulation, public Swig::Director {

public:
    SwigDirector_GISASSimulation(PyObject *self);
    SwigDirector_GISASSimulation(PyObject *self, ProgramOptions const *p_options);
    SwigDirector_GISASSimulation(PyObject *self, ISample const &p_sample, ProgramOptions const *p_options = 0);
    SwigDirector_GISASSimulation(PyObject *self, SampleBuilder_t p_sample_builder, ProgramOptions const *p_options = 0);
    SwigDirector_GISASSimulation(PyObject *self, GISASSimulation const &other);
    virtual ~SwigDirector_GISASSimulation();
    virtual GISASSimulation *clone() const;
    virtual void transferToCPP();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      IParameterized::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      GISASSimulation::init_parameters();
    }
    virtual void prepareSimulation();
    virtual int getNumberOfSimulationElements() const;
    virtual OutputData< double > *getDetectorIntensity(IDetector2D::EAxesUnits units_type = IDetector2D::DEFAULT) const;
    virtual void initSimulationElementVector();
    virtual void initSimulationElementVectorSwigPublic() {
      GISASSimulation::initSimulationElementVector();
    }
    virtual void transferResultsToIntensityMap();
    virtual void transferResultsToIntensityMapSwigPublic() {
      GISASSimulation::transferResultsToIntensityMap();
    }
    virtual double getBeamIntensity() const;
    virtual double getBeamIntensitySwigPublic() const {
      return GISASSimulation::getBeamIntensity();
    }

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class GISASSimulation doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[13];
#endif

};


class SwigDirector_IHistogram : public IHistogram, public Swig::Director {

public:
    SwigDirector_IHistogram(PyObject *self);
    SwigDirector_IHistogram(PyObject *self, IHistogram const &other);
    SwigDirector_IHistogram(PyObject *self, IAxis const &axis_x);
    SwigDirector_IHistogram(PyObject *self, IAxis const &axis_x, IAxis const &axis_y);
    virtual ~SwigDirector_IHistogram();
    virtual IHistogram *clone() const;
    virtual size_t getRank() const;

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class IHistogram doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[2];
#endif

};


class SwigDirector_Histogram1D : public Histogram1D, public Swig::Director {

public:
    SwigDirector_Histogram1D(PyObject *self, int nbinsx, double xlow, double xup);
    SwigDirector_Histogram1D(PyObject *self, int nbinsx, std::vector< double,std::allocator< double > > const &xbins);
    SwigDirector_Histogram1D(PyObject *self, IAxis const &axis);
    SwigDirector_Histogram1D(PyObject *self, OutputData< double > const &data);
    virtual ~SwigDirector_Histogram1D();
    virtual Histogram1D *clone() const;
    virtual size_t getRank() const;

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class Histogram1D doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[2];
#endif

};


class SwigDirector_Histogram2D : public Histogram2D, public Swig::Director {

public:
    SwigDirector_Histogram2D(PyObject *self, int nbinsx, double xlow, double xup, int nbinsy, double ylow, double yup);
    SwigDirector_Histogram2D(PyObject *self, int nbinsx, std::vector< double,std::allocator< double > > const &xbins, int nbinsy, std::vector< double,std::allocator< double > > const &ybins);
    SwigDirector_Histogram2D(PyObject *self, IAxis const &axis_x, IAxis const &axis_y);
    SwigDirector_Histogram2D(PyObject *self, OutputData< double > const &data);
    virtual ~SwigDirector_Histogram2D();
    virtual Histogram2D *clone() const;
    virtual size_t getRank() const;

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class Histogram2D doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[2];
#endif

};


class SwigDirector_HomogeneousMaterial : public HomogeneousMaterial, public Swig::Director {

public:
    SwigDirector_HomogeneousMaterial(PyObject *self, std::string const &name, complex_t const &refractive_index);
    SwigDirector_HomogeneousMaterial(PyObject *self, std::string const &name, double refractive_index_delta, double refractive_index_beta);
    virtual ~SwigDirector_HomogeneousMaterial();
    virtual HomogeneousMaterial *clone() const;
    virtual bool isScalarMaterial() const;
    virtual complex_t getRefractiveIndex() const;
    virtual IMaterial const *createTransformedMaterial(IRotation const &rotation) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      HomogeneousMaterial::print(ostr);
    }

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class HomogeneousMaterial doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[5];
#endif

};


class SwigDirector_HomogeneousMagneticMaterial : public HomogeneousMagneticMaterial, public Swig::Director {

public:
    SwigDirector_HomogeneousMagneticMaterial(PyObject *self, std::string const &name, complex_t const &refractive_index, kvector_t const &magnetic_field);
    SwigDirector_HomogeneousMagneticMaterial(PyObject *self, std::string const &name, double refractive_index_delta, double refractive_index_beta, kvector_t const &magnetic_field);
    virtual ~SwigDirector_HomogeneousMagneticMaterial();
    virtual HomogeneousMagneticMaterial *clone() const;
    virtual bool isScalarMaterial() const;
    virtual complex_t getRefractiveIndex() const;
    virtual IMaterial const *createTransformedMaterial(IRotation const &rotation) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      HomogeneousMagneticMaterial::print(ostr);
    }

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class HomogeneousMagneticMaterial doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[5];
#endif

};


class SwigDirector_IDetector2D : public IDetector2D, public Swig::Director {

public:
    SwigDirector_IDetector2D(PyObject *self);
    SwigDirector_IDetector2D(PyObject *self, IDetector2D const &other);
    virtual ~SwigDirector_IDetector2D();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      IParameterized::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      IDetector2D::init_parameters();
    }
    virtual IDetector2D *clone() const;
    virtual void init(Beam const &beam);
    virtual OutputData< double > *createDetectorMap(Beam const &beam, IDetector2D::EAxesUnits units_type) const;
    virtual std::vector< IDetector2D::EAxesUnits,std::allocator< IDetector2D::EAxesUnits > > getValidAxesUnits() const;
    virtual IDetector2D::EAxesUnits getDefaultAxesUnits() const;
    virtual IPixelMap *createPixelMap(size_t index) const;
    virtual IAxis *createAxis(size_t index, size_t n_bins, double min, double max) const;
    virtual std::string getAxisName(size_t index) const;

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class IDetector2D doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[12];
#endif

};


class SwigDirector_ILayout : public ILayout, public Swig::Director {

public:
    SwigDirector_ILayout(PyObject *self);
    virtual ~SwigDirector_ILayout();
    virtual ILayout *clone() const;
    virtual void transferToCPP();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      IParameterized::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      IParameterized::init_parameters();
    }
    virtual ILayout *cloneInvertB() const;
    virtual void accept(ISampleVisitor *visitor) const;
    virtual DWBASimulation *createDWBASimulation() const;
    virtual void printSampleTree();
    virtual bool containsMagneticMaterial() const;
    virtual std::vector< ISample const *,std::allocator< ISample const * > > getChildren() const;
    virtual size_t size() const;
    virtual void registerChild(ISample *sample);
    virtual void deregisterChild(ISample *sample);
    virtual size_t getNumberOfParticles() const;
    virtual IAbstractParticle const *getParticle(size_t index) const;
    virtual SafePointerVector< IParticle const > getParticles() const;
    virtual double getAbundanceOfParticle(size_t index) const;
    virtual IInterferenceFunction const *getInterferenceFunction() const;
    virtual double getTotalParticleSurfaceDensity() const;
    virtual void setTotalParticleSurfaceDensity(double particle_density);

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class ILayout doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[22];
#endif

};


class SwigDirector_IInterferenceFunction : public IInterferenceFunction, public Swig::Director {

public:
    SwigDirector_IInterferenceFunction(PyObject *self);
    virtual ~SwigDirector_IInterferenceFunction();
    virtual IInterferenceFunction *clone() const;
    virtual void transferToCPP();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      IParameterized::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      IParameterized::init_parameters();
    }
    virtual ISample *cloneInvertB() const;
    virtual void accept(ISampleVisitor *visitor) const;
    virtual DWBASimulation *createDWBASimulation() const;
    virtual void printSampleTree();
    virtual bool containsMagneticMaterial() const;
    virtual std::vector< ISample const *,std::allocator< ISample const * > > getChildren() const;
    virtual size_t size() const;
    virtual double evaluate(kvector_t const &q) const;
    virtual double getKappa() const;
    virtual double getParticleDensity() const;

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class IInterferenceFunction doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[16];
#endif

};


class SwigDirector_Instrument : public Instrument, public Swig::Director {

public:
    SwigDirector_Instrument(PyObject *self);
    SwigDirector_Instrument(PyObject *self, Instrument const &other);
    virtual ~SwigDirector_Instrument();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      Instrument::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      Instrument::init_parameters();
    }

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class Instrument doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[4];
#endif

};


class SwigDirector_InterferenceFunction1DLattice : public InterferenceFunction1DLattice, public Swig::Director {

public:
    SwigDirector_InterferenceFunction1DLattice(PyObject *self, double length, double xi);
    virtual ~SwigDirector_InterferenceFunction1DLattice();
    virtual InterferenceFunction1DLattice *clone() const;
    virtual void transferToCPP();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      IParameterized::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      IParameterized::init_parameters();
    }
    virtual ISample *cloneInvertB() const;
    virtual void accept(ISampleVisitor *visitor) const;
    virtual DWBASimulation *createDWBASimulation() const;
    virtual void printSampleTree();
    virtual bool containsMagneticMaterial() const;
    virtual std::vector< ISample const *,std::allocator< ISample const * > > getChildren() const;
    virtual size_t size() const;
    virtual double evaluate(kvector_t const &q) const;
    virtual double getKappa() const;
    virtual double getParticleDensity() const;

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class InterferenceFunction1DLattice doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[16];
#endif

};


class SwigDirector_InterferenceFunctionRadialParaCrystal : public InterferenceFunctionRadialParaCrystal, public Swig::Director {

public:
    SwigDirector_InterferenceFunctionRadialParaCrystal(PyObject *self, double peak_distance, double damping_length = 0.0);
    virtual ~SwigDirector_InterferenceFunctionRadialParaCrystal();
    virtual InterferenceFunctionRadialParaCrystal *clone() const;
    virtual void transferToCPP();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      IParameterized::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      IParameterized::init_parameters();
    }
    virtual ISample *cloneInvertB() const;
    virtual void accept(ISampleVisitor *visitor) const;
    virtual DWBASimulation *createDWBASimulation() const;
    virtual void printSampleTree();
    virtual bool containsMagneticMaterial() const;
    virtual std::vector< ISample const *,std::allocator< ISample const * > > getChildren() const;
    virtual size_t size() const;
    virtual double evaluate(kvector_t const &q) const;
    virtual double getKappa() const;
    virtual double getParticleDensity() const;

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class InterferenceFunctionRadialParaCrystal doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[16];
#endif

};


class SwigDirector_InterferenceFunction2DLattice : public InterferenceFunction2DLattice, public Swig::Director {

public:
    SwigDirector_InterferenceFunction2DLattice(PyObject *self, double length_1, double length_2, double angle, double xi = 0.0);
    virtual ~SwigDirector_InterferenceFunction2DLattice();
    virtual InterferenceFunction2DLattice *clone() const;
    virtual void transferToCPP();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      IParameterized::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      IParameterized::init_parameters();
    }
    virtual ISample *cloneInvertB() const;
    virtual void accept(ISampleVisitor *visitor) const;
    virtual DWBASimulation *createDWBASimulation() const;
    virtual void printSampleTree();
    virtual bool containsMagneticMaterial() const;
    virtual std::vector< ISample const *,std::allocator< ISample const * > > getChildren() const;
    virtual size_t size() const;
    virtual double evaluate(kvector_t const &q) const;
    virtual double getKappa() const;
    virtual double getParticleDensity() const;

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class InterferenceFunction2DLattice doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[16];
#endif

};


class SwigDirector_InterferenceFunction2DParaCrystal : public InterferenceFunction2DParaCrystal, public Swig::Director {

public:
    SwigDirector_InterferenceFunction2DParaCrystal(PyObject *self, double length_1, double length_2, double alpha_lattice, double xi = 0.0, double damping_length = 0.0);
    virtual ~SwigDirector_InterferenceFunction2DParaCrystal();
    virtual InterferenceFunction2DParaCrystal *clone() const;
    virtual void transferToCPP();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      IParameterized::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      InterferenceFunction2DParaCrystal::init_parameters();
    }
    virtual ISample *cloneInvertB() const;
    virtual void accept(ISampleVisitor *visitor) const;
    virtual DWBASimulation *createDWBASimulation() const;
    virtual void printSampleTree();
    virtual bool containsMagneticMaterial() const;
    virtual std::vector< ISample const *,std::allocator< ISample const * > > getChildren() const;
    virtual size_t size() const;
    virtual double evaluate(kvector_t const &q) const;
    virtual double getKappa() const;
    virtual double getParticleDensity() const;

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class InterferenceFunction2DParaCrystal doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[16];
#endif

};


class SwigDirector_InterferenceFunctionNone : public InterferenceFunctionNone, public Swig::Director {

public:
    SwigDirector_InterferenceFunctionNone(PyObject *self);
    virtual ~SwigDirector_InterferenceFunctionNone();
    virtual InterferenceFunctionNone *clone() const;
    virtual void transferToCPP();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      IParameterized::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      IParameterized::init_parameters();
    }
    virtual ISample *cloneInvertB() const;
    virtual void accept(ISampleVisitor *visitor) const;
    virtual DWBASimulation *createDWBASimulation() const;
    virtual void printSampleTree();
    virtual bool containsMagneticMaterial() const;
    virtual std::vector< ISample const *,std::allocator< ISample const * > > getChildren() const;
    virtual size_t size() const;
    virtual double evaluate(kvector_t const &q) const;
    virtual double getKappa() const;
    virtual double getParticleDensity() const;

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class InterferenceFunctionNone doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[16];
#endif

};


class SwigDirector_IObserver : public IObserver, public Swig::Director {

public:
    SwigDirector_IObserver(PyObject *self);
    virtual ~SwigDirector_IObserver();
    virtual void notify(IObservable *subject);

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class IObserver doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[1];
#endif

};


class SwigDirector_IObservable : public IObservable, public Swig::Director {

public:
    SwigDirector_IObservable(PyObject *self);
    virtual ~SwigDirector_IObservable();
    virtual void attachObserver(IObservable::observer_t obj);
    virtual void notifyObservers();

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class IObservable doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[2];
#endif

};


class SwigDirector_IAbstractParticle : public IAbstractParticle, public Swig::Director {

public:
    SwigDirector_IAbstractParticle(PyObject *self);
    virtual ~SwigDirector_IAbstractParticle();
    virtual IAbstractParticle *clone() const;
    virtual void transferToCPP();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      IParameterized::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      IParameterized::init_parameters();
    }
    virtual IAbstractParticle *cloneInvertB() const;
    virtual void accept(ISampleVisitor *visitor) const;
    virtual DWBASimulation *createDWBASimulation() const;
    virtual void printSampleTree();
    virtual bool containsMagneticMaterial() const;
    virtual std::vector< ISample const *,std::allocator< ISample const * > > getChildren() const;
    virtual size_t size() const;
    virtual void registerChild(ISample *sample);
    virtual void deregisterChild(ISample *sample);
    virtual void setAmbientMaterial(IMaterial const &material);
    virtual IMaterial const *getAmbientMaterial() const;

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class IAbstractParticle doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[17];
#endif

};


class SwigDirector_IParticle : public IParticle, public Swig::Director {

public:
    SwigDirector_IParticle(PyObject *self);
    virtual ~SwigDirector_IParticle();
    virtual IParticle *clone() const;
    virtual void transferToCPP();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      IParameterized::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      IParameterized::init_parameters();
    }
    virtual IParticle *cloneInvertB() const;
    virtual void accept(ISampleVisitor *visitor) const;
    virtual DWBASimulation *createDWBASimulation() const;
    virtual void printSampleTree();
    virtual bool containsMagneticMaterial() const;
    virtual std::vector< ISample const *,std::allocator< ISample const * > > getChildren() const;
    virtual size_t size() const;
    virtual void registerChild(ISample *sample);
    virtual void deregisterChild(ISample *sample);
    virtual void setAmbientMaterial(IMaterial const &material);
    virtual IMaterial const *getAmbientMaterial() const;
    virtual IFormFactor *createTransformedFormFactor(IRotation const *p_rotation, kvector_t translation) const;

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class IParticle doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[18];
#endif

};


class SwigDirector_IResolutionFunction2D : public IResolutionFunction2D, public Swig::Director {

public:
    SwigDirector_IResolutionFunction2D(PyObject *self);
    virtual ~SwigDirector_IResolutionFunction2D();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      IParameterized::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      IParameterized::init_parameters();
    }
    virtual double evaluateCDF(double x, double y) const;
    virtual IResolutionFunction2D *clone() const;

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class IResolutionFunction2D doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[6];
#endif

};


class SwigDirector_ISampleBuilder : public ISampleBuilder, public Swig::Director {

public:
    SwigDirector_ISampleBuilder(PyObject *self);
    virtual ~SwigDirector_ISampleBuilder();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      IParameterized::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      IParameterized::init_parameters();
    }
    virtual ISample *buildSample() const;
    virtual void init_from(IComponentService const *arg0);

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class ISampleBuilder doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[6];
#endif

};


class SwigDirector_ISelectionRule : public ISelectionRule, public Swig::Director {

public:
    SwigDirector_ISelectionRule(PyObject *self);
    virtual ~SwigDirector_ISelectionRule();
    virtual ISelectionRule *clone() const;
    virtual bool coordinateSelected(IndexVector3D const &coordinate) const;

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class ISelectionRule doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[2];
#endif

};


class SwigDirector_SimpleSelectionRule : public SimpleSelectionRule, public Swig::Director {

public:
    SwigDirector_SimpleSelectionRule(PyObject *self, int a, int b, int c, int modulus);
    virtual ~SwigDirector_SimpleSelectionRule();
    virtual SimpleSelectionRule *clone() const;
    virtual bool coordinateSelected(IndexVector3D const &coordinate) const;

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class SimpleSelectionRule doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[2];
#endif

};


class SwigDirector_IPixelMap : public IPixelMap, public Swig::Director {

public:
    SwigDirector_IPixelMap(PyObject *self);
    virtual ~SwigDirector_IPixelMap();
    virtual IPixelMap *clone() const;
    virtual IPixelMap *createZeroSizeMap(double x, double y) const;
    virtual kvector_t getK(double x, double y, double wavelength) const;
    virtual double getIntegrationFactor(double x, double y) const;
    virtual double getSolidAngle() const;

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class IPixelMap doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[5];
#endif

};


class SwigDirector_SphericalDetector : public SphericalDetector, public Swig::Director {

public:
    SwigDirector_SphericalDetector(PyObject *self);
    SwigDirector_SphericalDetector(PyObject *self, size_t n_phi, double phi_min, double phi_max, size_t n_alpha, double alpha_min, double alpha_max);
    SwigDirector_SphericalDetector(PyObject *self, SphericalDetector const &other);
    virtual ~SwigDirector_SphericalDetector();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      SphericalDetector::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      SphericalDetector::init_parameters();
    }
    virtual SphericalDetector *clone() const;
    virtual void init(Beam const &beam);
    virtual OutputData< double > *createDetectorMap(Beam const &beam, IDetector2D::EAxesUnits units_type) const;
    virtual std::vector< IDetector2D::EAxesUnits,std::allocator< IDetector2D::EAxesUnits > > getValidAxesUnits() const;
    virtual IDetector2D::EAxesUnits getDefaultAxesUnits() const;
    virtual IPixelMap *createPixelMap(size_t index) const;
    virtual IPixelMap *createPixelMapSwigPublic(size_t index) const {
      return SphericalDetector::createPixelMap(index);
    }
    virtual IAxis *createAxis(size_t index, size_t n_bins, double min, double max) const;
    virtual IAxis *createAxisSwigPublic(size_t index, size_t n_bins, double min, double max) const {
      return SphericalDetector::createAxis(index,n_bins,min,max);
    }
    virtual std::string getAxisName(size_t index) const;
    virtual std::string getAxisNameSwigPublic(size_t index) const {
      return SphericalDetector::getAxisName(index);
    }

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class SphericalDetector doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[12];
#endif

};


class SwigDirector_AngularPixelMap : public AngularPixelMap, public Swig::Director {

public:
    SwigDirector_AngularPixelMap(PyObject *self, Bin1D alpha_bin, Bin1D phi_bin);
    virtual ~SwigDirector_AngularPixelMap();
    virtual AngularPixelMap *clone() const;
    virtual AngularPixelMap *createZeroSizeMap(double x, double y) const;
    virtual kvector_t getK(double x, double y, double wavelength) const;
    virtual double getIntegrationFactor(double x, double y) const;
    virtual double getSolidAngle() const;

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class AngularPixelMap doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[5];
#endif

};


class SwigDirector_IsGISAXSDetector : public IsGISAXSDetector, public Swig::Director {

public:
    SwigDirector_IsGISAXSDetector(PyObject *self);
    SwigDirector_IsGISAXSDetector(PyObject *self, size_t n_phi, double phi_min, double phi_max, size_t n_alpha, double alpha_min, double alpha_max);
    SwigDirector_IsGISAXSDetector(PyObject *self, IsGISAXSDetector const &other);
    virtual ~SwigDirector_IsGISAXSDetector();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      IsGISAXSDetector::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      SphericalDetector::init_parameters();
    }
    virtual IsGISAXSDetector *clone() const;
    virtual void init(Beam const &beam);
    virtual OutputData< double > *createDetectorMap(Beam const &beam, IDetector2D::EAxesUnits units_type) const;
    virtual std::vector< IDetector2D::EAxesUnits,std::allocator< IDetector2D::EAxesUnits > > getValidAxesUnits() const;
    virtual IDetector2D::EAxesUnits getDefaultAxesUnits() const;
    virtual IPixelMap *createPixelMap(size_t index) const;
    virtual IPixelMap *createPixelMapSwigPublic(size_t index) const {
      return SphericalDetector::createPixelMap(index);
    }
    virtual IAxis *createAxis(size_t index, size_t n_bins, double min, double max) const;
    virtual IAxis *createAxisSwigPublic(size_t index, size_t n_bins, double min, double max) const {
      return IsGISAXSDetector::createAxis(index,n_bins,min,max);
    }
    virtual std::string getAxisName(size_t index) const;
    virtual std::string getAxisNameSwigPublic(size_t index) const {
      return SphericalDetector::getAxisName(index);
    }

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class IsGISAXSDetector doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[12];
#endif

};


class SwigDirector_IRoughness : public IRoughness, public Swig::Director {

public:
    SwigDirector_IRoughness(PyObject *self);
    virtual ~SwigDirector_IRoughness();
    virtual ISample *clone() const;
    virtual void transferToCPP();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      IParameterized::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      IParameterized::init_parameters();
    }
    virtual ISample *cloneInvertB() const;
    virtual void accept(ISampleVisitor *visitor) const;
    virtual DWBASimulation *createDWBASimulation() const;
    virtual void printSampleTree();
    virtual bool containsMagneticMaterial() const;
    virtual std::vector< ISample const *,std::allocator< ISample const * > > getChildren() const;
    virtual size_t size() const;

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class IRoughness doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[13];
#endif

};


class SwigDirector_Layer : public Layer, public Swig::Director {

public:
    SwigDirector_Layer(PyObject *self);
    SwigDirector_Layer(PyObject *self, IMaterial const &material, double thickness = 0);
    SwigDirector_Layer(PyObject *self, Layer const &other);
    virtual ~SwigDirector_Layer();
    virtual Layer *clone() const;
    virtual void transferToCPP();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      Layer::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      Layer::init_parameters();
    }
    virtual Layer *cloneInvertB() const;
    virtual void accept(ISampleVisitor *visitor) const;
    virtual DWBASimulation *createDWBASimulation() const;
    virtual void printSampleTree();
    virtual bool containsMagneticMaterial() const;
    virtual std::vector< ISample const *,std::allocator< ISample const * > > getChildren() const;
    virtual size_t size() const;
    virtual void registerChild(ISample *sample);
    virtual void deregisterChild(ISample *sample);
    virtual void setThickness(double thickness);
    virtual double getThickness() const;
    virtual void setMaterial(IMaterial const &material);
    virtual void setMaterialAndThickness(IMaterial const &material, double thickness);
    virtual IMaterial const *getMaterial() const;
    virtual complex_t getRefractiveIndex() const;
    virtual void addLayout(ILayout const &decoration);
    virtual ILayout const *getLayout(size_t i) const;
    virtual bool hasDWBASimulation() const;
    virtual void addLayoutPtr(ILayout *layout);
    virtual void addLayoutPtrSwigPublic(ILayout *layout) {
      Layer::addLayoutPtr(layout);
    }

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class Layer doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[25];
#endif

};


class SwigDirector_LayerRoughness : public LayerRoughness, public Swig::Director {

public:
    SwigDirector_LayerRoughness(PyObject *self);
    SwigDirector_LayerRoughness(PyObject *self, double sigma, double hurstParameter, double latteralCorrLength);
    virtual ~SwigDirector_LayerRoughness();
    virtual LayerRoughness *clone() const;
    virtual void transferToCPP();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      LayerRoughness::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      LayerRoughness::init_parameters();
    }
    virtual ISample *cloneInvertB() const;
    virtual void accept(ISampleVisitor *visitor) const;
    virtual DWBASimulation *createDWBASimulation() const;
    virtual void printSampleTree();
    virtual bool containsMagneticMaterial() const;
    virtual std::vector< ISample const *,std::allocator< ISample const * > > getChildren() const;
    virtual size_t size() const;

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class LayerRoughness doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[13];
#endif

};


class SwigDirector_Line : public Geometry::Line, public Swig::Director {

public:
    SwigDirector_Line(PyObject *self, double x1, double y1, double x2, double y2);
    virtual ~SwigDirector_Line();
    virtual Geometry::Line *clone() const;
    virtual void transferToCPP();
    virtual bool contains(double x, double y) const;
    virtual bool contains(Bin1D const &binx, Bin1D const &biny) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      Geometry::IShape2D::print(ostr);
    }

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class Line doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[5];
#endif

};


class SwigDirector_VerticalLine : public Geometry::VerticalLine, public Swig::Director {

public:
    SwigDirector_VerticalLine(PyObject *self, double x);
    virtual ~SwigDirector_VerticalLine();
    virtual Geometry::VerticalLine *clone() const;
    virtual void transferToCPP();
    virtual bool contains(double x, double y) const;
    virtual bool contains(Bin1D const &binx, Bin1D const &biny) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      Geometry::IShape2D::print(ostr);
    }

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class VerticalLine doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[5];
#endif

};


class SwigDirector_HorizontalLine : public Geometry::HorizontalLine, public Swig::Director {

public:
    SwigDirector_HorizontalLine(PyObject *self, double y);
    virtual ~SwigDirector_HorizontalLine();
    virtual Geometry::HorizontalLine *clone() const;
    virtual void transferToCPP();
    virtual bool contains(double x, double y) const;
    virtual bool contains(Bin1D const &binx, Bin1D const &biny) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      Geometry::IShape2D::print(ostr);
    }

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class HorizontalLine doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[5];
#endif

};


class SwigDirector_MesoCrystal : public MesoCrystal, public Swig::Director {

public:
    SwigDirector_MesoCrystal(PyObject *self, IClusteredParticles const &particle_structure, IFormFactor &form_factor);
    virtual ~SwigDirector_MesoCrystal();
    virtual MesoCrystal *clone() const;
    virtual void transferToCPP();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      IParameterized::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      IParameterized::init_parameters();
    }
    virtual MesoCrystal *cloneInvertB() const;
    virtual void accept(ISampleVisitor *visitor) const;
    virtual DWBASimulation *createDWBASimulation() const;
    virtual void printSampleTree();
    virtual bool containsMagneticMaterial() const;
    virtual std::vector< ISample const *,std::allocator< ISample const * > > getChildren() const;
    virtual size_t size() const;
    virtual void registerChild(ISample *sample);
    virtual void deregisterChild(ISample *sample);
    virtual void setAmbientMaterial(IMaterial const &material);
    virtual IMaterial const *getAmbientMaterial() const;
    virtual IFormFactor *createTransformedFormFactor(IRotation const *p_rotation, kvector_t translation) const;

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class MesoCrystal doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[18];
#endif

};


class SwigDirector_MultiLayer : public MultiLayer, public Swig::Director {

public:
    SwigDirector_MultiLayer(PyObject *self);
    virtual ~SwigDirector_MultiLayer();
    virtual MultiLayer *clone() const;
    virtual void transferToCPP();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      MultiLayer::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      MultiLayer::init_parameters();
    }
    virtual MultiLayer *cloneInvertB() const;
    virtual void accept(ISampleVisitor *visitor) const;
    virtual MultiLayerDWBASimulation *createDWBASimulation() const;
    virtual void printSampleTree();
    virtual bool containsMagneticMaterial() const;
    virtual std::vector< ISample const *,std::allocator< ISample const * > > getChildren() const;
    virtual size_t size() const;
    virtual void registerChild(ISample *sample);
    virtual void deregisterChild(ISample *sample);

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class MultiLayer doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[15];
#endif

};


class SwigDirector_OffSpecSimulation : public OffSpecSimulation, public Swig::Director {

public:
    SwigDirector_OffSpecSimulation(PyObject *self);
    SwigDirector_OffSpecSimulation(PyObject *self, ProgramOptions const *p_options);
    SwigDirector_OffSpecSimulation(PyObject *self, ISample const &p_sample, ProgramOptions const *p_options = 0);
    SwigDirector_OffSpecSimulation(PyObject *self, SampleBuilder_t p_sample_builder, ProgramOptions const *p_options = 0);
    SwigDirector_OffSpecSimulation(PyObject *self, OffSpecSimulation const &other);
    virtual ~SwigDirector_OffSpecSimulation();
    virtual OffSpecSimulation *clone() const;
    virtual void transferToCPP();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      IParameterized::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      OffSpecSimulation::init_parameters();
    }
    virtual void prepareSimulation();
    virtual int getNumberOfSimulationElements() const;
    virtual OutputData< double > *getDetectorIntensity(IDetector2D::EAxesUnits units_type = IDetector2D::DEFAULT) const;
    virtual void initSimulationElementVector();
    virtual void initSimulationElementVectorSwigPublic() {
      OffSpecSimulation::initSimulationElementVector();
    }
    virtual void transferResultsToIntensityMap();
    virtual void transferResultsToIntensityMapSwigPublic() {
      OffSpecSimulation::transferResultsToIntensityMap();
    }
    virtual double getBeamIntensity() const;
    virtual double getBeamIntensitySwigPublic() const {
      return OffSpecSimulation::getBeamIntensity();
    }

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class OffSpecSimulation doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[13];
#endif

};


class SwigDirector_ParameterDistribution : public ParameterDistribution, public Swig::Director {

public:
    SwigDirector_ParameterDistribution(PyObject *self, std::string const &par_name, IDistribution1D const &distribution, size_t nbr_samples, double sigma_factor = 0.0, AttLimits const &limits = AttLimits());
    SwigDirector_ParameterDistribution(PyObject *self, std::string const &par_name, IDistribution1D const &distribution, size_t nbr_samples, double xmin, double xmax);
    SwigDirector_ParameterDistribution(PyObject *self, ParameterDistribution const &other);
    virtual ~SwigDirector_ParameterDistribution();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      IParameterized::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      ParameterDistribution::init_parameters();
    }

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class ParameterDistribution doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[4];
#endif

};


class SwigDirector_ParameterPool : public ParameterPool, public Swig::Director {

public:
    SwigDirector_ParameterPool(PyObject *self);
    virtual ~SwigDirector_ParameterPool();
    virtual ParameterPool *clone() const;
    virtual void transferToCPP();
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      ParameterPool::print(ostr);
    }

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class ParameterPool doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[3];
#endif

};


class SwigDirector_Particle : public Particle, public Swig::Director {

public:
    SwigDirector_Particle(PyObject *self);
    SwigDirector_Particle(PyObject *self, IMaterial const &p_material);
    SwigDirector_Particle(PyObject *self, IMaterial const &p_material, IFormFactor const &form_factor);
    SwigDirector_Particle(PyObject *self, IMaterial const &p_material, IFormFactor const &form_factor, IRotation const &rotation);
    virtual ~SwigDirector_Particle();
    virtual Particle *clone() const;
    virtual void transferToCPP();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      IParameterized::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      IParameterized::init_parameters();
    }
    virtual Particle *cloneInvertB() const;
    virtual void accept(ISampleVisitor *visitor) const;
    virtual DWBASimulation *createDWBASimulation() const;
    virtual void printSampleTree();
    virtual bool containsMagneticMaterial() const;
    virtual std::vector< ISample const *,std::allocator< ISample const * > > getChildren() const;
    virtual size_t size() const;
    virtual void registerChild(ISample *sample);
    virtual void deregisterChild(ISample *sample);
    virtual void setAmbientMaterial(IMaterial const &material);
    virtual IMaterial const *getAmbientMaterial() const;
    virtual IFormFactor *createTransformedFormFactor(IRotation const *p_rotation, kvector_t translation) const;
    virtual void setMaterial(IMaterial const &material);
    virtual IMaterial const *getMaterial() const;
    virtual complex_t getRefractiveIndex() const;

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class Particle doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[21];
#endif

};


class SwigDirector_ParticleComposition : public ParticleComposition, public Swig::Director {

public:
    SwigDirector_ParticleComposition(PyObject *self);
    SwigDirector_ParticleComposition(PyObject *self, IParticle const &particle);
    SwigDirector_ParticleComposition(PyObject *self, IParticle const &particle, kvector_t position);
    SwigDirector_ParticleComposition(PyObject *self, IParticle const &particle, std::vector< kvector_t,std::allocator< kvector_t > > positions);
    virtual ~SwigDirector_ParticleComposition();
    virtual ParticleComposition *clone() const;
    virtual void transferToCPP();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      IParameterized::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      IParameterized::init_parameters();
    }
    virtual ParticleComposition *cloneInvertB() const;
    virtual void accept(ISampleVisitor *visitor) const;
    virtual DWBASimulation *createDWBASimulation() const;
    virtual void printSampleTree();
    virtual bool containsMagneticMaterial() const;
    virtual std::vector< ISample const *,std::allocator< ISample const * > > getChildren() const;
    virtual size_t size() const;
    virtual void registerChild(ISample *sample);
    virtual void deregisterChild(ISample *sample);
    virtual void setAmbientMaterial(IMaterial const &material);
    virtual IMaterial const *getAmbientMaterial() const;
    virtual IFormFactor *createTransformedFormFactor(IRotation const *p_rotation, kvector_t translation) const;

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class ParticleComposition doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[18];
#endif

};


class SwigDirector_ParticleCoreShell : public ParticleCoreShell, public Swig::Director {

public:
    SwigDirector_ParticleCoreShell(PyObject *self, Particle const &shell, Particle const &core, kvector_t relative_core_position = kvector_t(0.0, 0.0, 0.0));
    SwigDirector_ParticleCoreShell(PyObject *self);
    virtual ~SwigDirector_ParticleCoreShell();
    virtual ParticleCoreShell *clone() const;
    virtual void transferToCPP();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      IParameterized::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      IParameterized::init_parameters();
    }
    virtual ParticleCoreShell *cloneInvertB() const;
    virtual void accept(ISampleVisitor *visitor) const;
    virtual DWBASimulation *createDWBASimulation() const;
    virtual void printSampleTree();
    virtual bool containsMagneticMaterial() const;
    virtual std::vector< ISample const *,std::allocator< ISample const * > > getChildren() const;
    virtual size_t size() const;
    virtual void registerChild(ISample *sample);
    virtual void deregisterChild(ISample *sample);
    virtual void setAmbientMaterial(IMaterial const &material);
    virtual IMaterial const *getAmbientMaterial() const;
    virtual IFormFactor *createTransformedFormFactor(IRotation const *p_rotation, kvector_t translation) const;

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class ParticleCoreShell doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[18];
#endif

};


class SwigDirector_ParticleDistribution : public ParticleDistribution, public Swig::Director {

public:
    SwigDirector_ParticleDistribution(PyObject *self, IParticle const &prototype, ParameterDistribution const &par_distr);
    virtual ~SwigDirector_ParticleDistribution();
    virtual ParticleDistribution *clone() const;
    virtual void transferToCPP();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      IParameterized::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      IParameterized::init_parameters();
    }
    virtual ParticleDistribution *cloneInvertB() const;
    virtual void accept(ISampleVisitor *visitor) const;
    virtual DWBASimulation *createDWBASimulation() const;
    virtual void printSampleTree();
    virtual bool containsMagneticMaterial() const;
    virtual std::vector< ISample const *,std::allocator< ISample const * > > getChildren() const;
    virtual size_t size() const;
    virtual void registerChild(ISample *sample);
    virtual void deregisterChild(ISample *sample);
    virtual void setAmbientMaterial(IMaterial const &material);
    virtual IMaterial const *getAmbientMaterial() const;
    virtual void generateParticles(std::vector< IParticle const *,std::allocator< IParticle const * > > &particle_vector) const;

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class ParticleDistribution doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[18];
#endif

};


class SwigDirector_ParticleLayout : public ParticleLayout, public Swig::Director {

public:
    SwigDirector_ParticleLayout(PyObject *self);
    SwigDirector_ParticleLayout(PyObject *self, IAbstractParticle const &particle);
    SwigDirector_ParticleLayout(PyObject *self, IAbstractParticle const &particle, double abundance);
    virtual ~SwigDirector_ParticleLayout();
    virtual ParticleLayout *clone() const;
    virtual void transferToCPP();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      IParameterized::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      IParameterized::init_parameters();
    }
    virtual ParticleLayout *cloneInvertB() const;
    virtual void accept(ISampleVisitor *visitor) const;
    virtual DWBASimulation *createDWBASimulation() const;
    virtual void printSampleTree();
    virtual bool containsMagneticMaterial() const;
    virtual std::vector< ISample const *,std::allocator< ISample const * > > getChildren() const;
    virtual size_t size() const;
    virtual void registerChild(ISample *sample);
    virtual void deregisterChild(ISample *sample);
    virtual size_t getNumberOfParticles() const;
    virtual IAbstractParticle const *getParticle(size_t index) const;
    virtual SafePointerVector< IParticle const > getParticles() const;
    virtual double getAbundanceOfParticle(size_t index) const;
    virtual IInterferenceFunction const *getInterferenceFunction() const;
    virtual double getTotalParticleSurfaceDensity() const;
    virtual void setTotalParticleSurfaceDensity(double particle_density);
    virtual void addParticle(IAbstractParticle const &particle);
    virtual void addParticle(IAbstractParticle const &particle, double abundance);
    virtual void addParticle(IParticle const &particle, double abundance, kvector_t const &position);
    virtual void addParticle(IParticle const &particle, double abundance, kvector_t const &position, IRotation const &rotation);

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class ParticleLayout doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[26];
#endif

};


class SwigDirector_Polygon : public Geometry::Polygon, public Swig::Director {

public:
    SwigDirector_Polygon(PyObject *self, std::vector< double,std::allocator< double > > x, std::vector< double,std::allocator< double > > y);
    SwigDirector_Polygon(PyObject *self, std::vector< std::vector< double,std::allocator< double > >,std::allocator< std::vector< double,std::allocator< double > > > > points);
    virtual ~SwigDirector_Polygon();
    virtual Geometry::Polygon *clone() const;
    virtual void transferToCPP();
    virtual bool contains(double x, double y) const;
    virtual bool contains(Bin1D const &binx, Bin1D const &biny) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      Geometry::Polygon::print(ostr);
    }

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class Polygon doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[5];
#endif

};


class SwigDirector_Rectangle : public Geometry::Rectangle, public Swig::Director {

public:
    SwigDirector_Rectangle(PyObject *self, double xlow, double ylow, double xup, double yup);
    virtual ~SwigDirector_Rectangle();
    virtual Geometry::Rectangle *clone() const;
    virtual void transferToCPP();
    virtual bool contains(double x, double y) const;
    virtual bool contains(Bin1D const &binx, Bin1D const &biny) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      Geometry::IShape2D::print(ostr);
    }

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class Rectangle doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[5];
#endif

};


class SwigDirector_RectangularDetector : public RectangularDetector, public Swig::Director {

public:
    SwigDirector_RectangularDetector(PyObject *self, int nxbins, double width, int nybins, double height);
    SwigDirector_RectangularDetector(PyObject *self, RectangularDetector const &other);
    virtual ~SwigDirector_RectangularDetector();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      RectangularDetector::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      RectangularDetector::init_parameters();
    }
    virtual RectangularDetector *clone() const;
    virtual void init(Beam const &beam);
    virtual OutputData< double > *createDetectorMap(Beam const &beam, IDetector2D::EAxesUnits units_type) const;
    virtual std::vector< IDetector2D::EAxesUnits,std::allocator< IDetector2D::EAxesUnits > > getValidAxesUnits() const;
    virtual IDetector2D::EAxesUnits getDefaultAxesUnits() const;
    virtual IPixelMap *createPixelMap(size_t index) const;
    virtual IPixelMap *createPixelMapSwigPublic(size_t index) const {
      return RectangularDetector::createPixelMap(index);
    }
    virtual IAxis *createAxis(size_t index, size_t n_bins, double min, double max) const;
    virtual IAxis *createAxisSwigPublic(size_t index, size_t n_bins, double min, double max) const {
      return RectangularDetector::createAxis(index,n_bins,min,max);
    }
    virtual std::string getAxisName(size_t index) const;
    virtual std::string getAxisNameSwigPublic(size_t index) const {
      return RectangularDetector::getAxisName(index);
    }

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class RectangularDetector doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[12];
#endif

};


class SwigDirector_RectPixelMap : public RectPixelMap, public Swig::Director {

public:
    SwigDirector_RectPixelMap(PyObject *self, kvector_t corner_pos, kvector_t width, kvector_t height);
    virtual ~SwigDirector_RectPixelMap();
    virtual RectPixelMap *clone() const;
    virtual RectPixelMap *createZeroSizeMap(double x, double y) const;
    virtual kvector_t getK(double x, double y, double wavelength) const;
    virtual double getIntegrationFactor(double x, double y) const;
    virtual double getSolidAngle() const;

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class RectPixelMap doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[5];
#endif

};


class SwigDirector_ResolutionFunction2DGaussian : public ResolutionFunction2DGaussian, public Swig::Director {

public:
    SwigDirector_ResolutionFunction2DGaussian(PyObject *self, double sigma_x, double sigma_y);
    virtual ~SwigDirector_ResolutionFunction2DGaussian();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      IParameterized::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      ResolutionFunction2DGaussian::init_parameters();
    }
    virtual double evaluateCDF(double x, double y) const;
    virtual ResolutionFunction2DGaussian *clone() const;

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class ResolutionFunction2DGaussian doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[6];
#endif

};


class SwigDirector_IRotation : public IRotation, public Swig::Director {

public:
    SwigDirector_IRotation(PyObject *self);
    virtual ~SwigDirector_IRotation();
    virtual IRotation *clone() const;
    virtual void transferToCPP();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      IParameterized::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      IParameterized::init_parameters();
    }
    virtual IRotation *cloneInvertB() const;
    virtual void accept(ISampleVisitor *visitor) const;
    virtual DWBASimulation *createDWBASimulation() const;
    virtual void printSampleTree();
    virtual bool containsMagneticMaterial() const;
    virtual std::vector< ISample const *,std::allocator< ISample const * > > getChildren() const;
    virtual size_t size() const;
    virtual IRotation *createInverse() const;
    virtual Geometry::Transform3D getTransform3D() const;
    virtual bool isIdentity() const;

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class IRotation doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[16];
#endif

};


class SwigDirector_RotationX : public RotationX, public Swig::Director {

public:
    SwigDirector_RotationX(PyObject *self, double angle);
    virtual ~SwigDirector_RotationX();
    virtual RotationX *clone() const;
    virtual void transferToCPP();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      IParameterized::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      RotationX::init_parameters();
    }
    virtual RotationX *cloneInvertB() const;
    virtual void accept(ISampleVisitor *visitor) const;
    virtual DWBASimulation *createDWBASimulation() const;
    virtual void printSampleTree();
    virtual bool containsMagneticMaterial() const;
    virtual std::vector< ISample const *,std::allocator< ISample const * > > getChildren() const;
    virtual size_t size() const;
    virtual RotationX *createInverse() const;
    virtual Geometry::Transform3D getTransform3D() const;
    virtual bool isIdentity() const;

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class RotationX doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[16];
#endif

};


class SwigDirector_RotationY : public RotationY, public Swig::Director {

public:
    SwigDirector_RotationY(PyObject *self, double angle);
    virtual ~SwigDirector_RotationY();
    virtual RotationY *clone() const;
    virtual void transferToCPP();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      IParameterized::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      RotationY::init_parameters();
    }
    virtual RotationY *cloneInvertB() const;
    virtual void accept(ISampleVisitor *visitor) const;
    virtual DWBASimulation *createDWBASimulation() const;
    virtual void printSampleTree();
    virtual bool containsMagneticMaterial() const;
    virtual std::vector< ISample const *,std::allocator< ISample const * > > getChildren() const;
    virtual size_t size() const;
    virtual RotationY *createInverse() const;
    virtual Geometry::Transform3D getTransform3D() const;
    virtual bool isIdentity() const;

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class RotationY doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[16];
#endif

};


class SwigDirector_RotationZ : public RotationZ, public Swig::Director {

public:
    SwigDirector_RotationZ(PyObject *self, double angle = 0.0);
    virtual ~SwigDirector_RotationZ();
    virtual RotationZ *clone() const;
    virtual void transferToCPP();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      IParameterized::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      RotationZ::init_parameters();
    }
    virtual RotationZ *cloneInvertB() const;
    virtual void accept(ISampleVisitor *visitor) const;
    virtual DWBASimulation *createDWBASimulation() const;
    virtual void printSampleTree();
    virtual bool containsMagneticMaterial() const;
    virtual std::vector< ISample const *,std::allocator< ISample const * > > getChildren() const;
    virtual size_t size() const;
    virtual RotationZ *createInverse() const;
    virtual Geometry::Transform3D getTransform3D() const;
    virtual bool isIdentity() const;

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class RotationZ doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[16];
#endif

};


class SwigDirector_RotationEuler : public RotationEuler, public Swig::Director {

public:
    SwigDirector_RotationEuler(PyObject *self, double alpha, double beta, double gamma);
    virtual ~SwigDirector_RotationEuler();
    virtual RotationEuler *clone() const;
    virtual void transferToCPP();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      IParameterized::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      RotationEuler::init_parameters();
    }
    virtual RotationEuler *cloneInvertB() const;
    virtual void accept(ISampleVisitor *visitor) const;
    virtual DWBASimulation *createDWBASimulation() const;
    virtual void printSampleTree();
    virtual bool containsMagneticMaterial() const;
    virtual std::vector< ISample const *,std::allocator< ISample const * > > getChildren() const;
    virtual size_t size() const;
    virtual IRotation *createInverse() const;
    virtual Geometry::Transform3D getTransform3D() const;
    virtual bool isIdentity() const;

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class RotationEuler doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[16];
#endif

};


class SwigDirector_SpecularSimulation : public SpecularSimulation, public Swig::Director {

public:
    SwigDirector_SpecularSimulation(PyObject *self);
    SwigDirector_SpecularSimulation(PyObject *self, ISample const &sample);
    SwigDirector_SpecularSimulation(PyObject *self, SampleBuilder_t sample_builder);
    SwigDirector_SpecularSimulation(PyObject *self, SpecularSimulation const &other);
    virtual ~SwigDirector_SpecularSimulation();
    virtual SpecularSimulation *clone() const;
    virtual void transferToCPP();
    virtual std::string addParametersToExternalPool(std::string path, ParameterPool *external_pool, int copy_number = -1) const;
    virtual void print(std::ostream &ostr) const;
    virtual void printSwigPublic(std::ostream &ostr) const {
      IParameterized::print(ostr);
    }
    virtual void init_parameters();
    virtual void init_parametersSwigPublic() {
      SpecularSimulation::init_parameters();
    }

/* Internal director utilities */
public:
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    }
private:
    mutable std::map<std::string, bool> swig_inner;

#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (!method) {
          std::string msg = "Method in class SpecularSimulation doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      }
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[6];
#endif

};


#endif
