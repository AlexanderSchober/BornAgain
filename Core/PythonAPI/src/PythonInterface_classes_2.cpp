// This file has been generated by Py++.

#include "boost/python.hpp"
#include "Types.h"
#include "PythonPlusplusHelper.h"
#include "Units.h"
#include "IMaterial.h"
#include "HomogeneousMaterial.h"
#include "ISingleton.h"
#include "MaterialManager.h"
#include "LayerRoughness.h"
#include "Layer.h"
#include "MultiLayer.h"
#include "ParameterPool.h"
#include "OpticalFresnel.h"
#include "PythonInterface_classes_2.h"

namespace bp = boost::python;

struct Layer_wrapper : Layer, bp::wrapper< Layer > {

    Layer_wrapper( )
    : Layer( )
      , bp::wrapper< Layer >(){
        // null constructor
    
    }

    Layer_wrapper(::Layer const & other )
    : Layer( boost::ref(other) )
      , bp::wrapper< Layer >(){
        // copy constructor
    
    }

    virtual ::IMaterial const * getMaterial(  ) const  {
        if( bp::override func_getMaterial = this->get_override( "getMaterial" ) )
            return func_getMaterial(  );
        else{
            return this->Layer::getMaterial(  );
        }
    }
    
    ::IMaterial const * default_getMaterial(  ) const  {
        return Layer::getMaterial( );
    }

    virtual void setMaterial( ::IMaterial const * p_material ) {
        if( bp::override func_setMaterial = this->get_override( "setMaterial" ) )
            func_setMaterial( boost::python::ptr(p_material) );
        else{
            this->Layer::setMaterial( boost::python::ptr(p_material) );
        }
    }
    
    void default_setMaterial( ::IMaterial const * p_material ) {
        Layer::setMaterial( boost::python::ptr(p_material) );
    }

    virtual void setMaterial( ::IMaterial const * p_material, double thickness ) {
        if( bp::override func_setMaterial = this->get_override( "setMaterial" ) )
            func_setMaterial( boost::python::ptr(p_material), thickness );
        else{
            this->Layer::setMaterial( boost::python::ptr(p_material), thickness );
        }
    }
    
    void default_setMaterial( ::IMaterial const * p_material, double thickness ) {
        Layer::setMaterial( boost::python::ptr(p_material), thickness );
    }

};

void register_classes_2(){

    bp::class_< ISingleton< MaterialManager >, boost::noncopyable >( "ISingleton_less__MaterialManager__greater_", bp::no_init )    
        .def( 
            "instance"
            , (::MaterialManager & (*)(  ))( &::ISingleton< MaterialManager >::instance )
            , bp::return_value_policy< bp::reference_existing_object >() )    
        .staticmethod( "instance" );

    { //::KVector< double >
        typedef bp::class_< KVector< double > > kvector_t_exposer_t;
        kvector_t_exposer_t kvector_t_exposer = kvector_t_exposer_t( "kvector_t", bp::init< >() );
        bp::scope kvector_t_scope( kvector_t_exposer );
        kvector_t_exposer.def( bp::init< double, double, double >(( bp::arg("x"), bp::arg("y"), bp::arg("z") )) );
        { //::KVector< double >::LambdaAlphaPhi
        
            typedef KVector< double > exported_class_t;
            typedef ::KVector< double > ( *LambdaAlphaPhi_function_type )( double,double,double );
            
            kvector_t_exposer.def( 
                "LambdaAlphaPhi"
                , LambdaAlphaPhi_function_type( &::KVector< double >::LambdaAlphaPhi )
                , ( bp::arg("lambda"), bp::arg("alpha"), bp::arg("phi") ) );
        
        }
        { //::KVector< double >::mag
        
            typedef KVector< double > exported_class_t;
            typedef double ( exported_class_t::*mag_function_type )(  ) const;
            
            kvector_t_exposer.def( 
                "mag"
                , mag_function_type( &::KVector< double >::mag ) );
        
        }
        { //::KVector< double >::mag2
        
            typedef KVector< double > exported_class_t;
            typedef double ( exported_class_t::*mag2_function_type )(  ) const;
            
            kvector_t_exposer.def( 
                "mag2"
                , mag2_function_type( &::KVector< double >::mag2 ) );
        
        }
        { //::KVector< double >::magxy
        
            typedef KVector< double > exported_class_t;
            typedef double ( exported_class_t::*magxy_function_type )(  ) const;
            
            kvector_t_exposer.def( 
                "magxy"
                , magxy_function_type( &::KVector< double >::magxy ) );
        
        }
        kvector_t_exposer.def( bp::self += bp::self );
        kvector_t_exposer.def( bp::self -= bp::self );
        { //::KVector< double >::operator=
        
            typedef KVector< double > exported_class_t;
            typedef ::KVector< double > & ( exported_class_t::*assign_function_type )( ::KVector< double > const & ) ;
            
            kvector_t_exposer.def( 
                "assign"
                , assign_function_type( &::KVector< double >::operator= )
                , ( bp::arg("other") )
                , bp::return_self< >() );
        
        }
        { //::KVector< double >::setLambdaAlphaPhi
        
            typedef KVector< double > exported_class_t;
            typedef void ( exported_class_t::*setLambdaAlphaPhi_function_type )( double,double,double ) ;
            
            kvector_t_exposer.def( 
                "setLambdaAlphaPhi"
                , setLambdaAlphaPhi_function_type( &::KVector< double >::setLambdaAlphaPhi )
                , ( bp::arg("lambda"), bp::arg("alpha"), bp::arg("phi") ) );
        
        }
        { //::KVector< double >::setMagThetaPhi
        
            typedef KVector< double > exported_class_t;
            typedef void ( exported_class_t::*setMagThetaPhi_function_type )( double,double,double ) ;
            
            kvector_t_exposer.def( 
                "setMagThetaPhi"
                , setMagThetaPhi_function_type( &::KVector< double >::setMagThetaPhi )
                , ( bp::arg("mag"), bp::arg("theta"), bp::arg("phi") ) );
        
        }
        { //::KVector< double >::x
        
            typedef KVector< double > exported_class_t;
            typedef double ( exported_class_t::*x_function_type )(  ) const;
            
            kvector_t_exposer.def( 
                "x"
                , x_function_type( &::KVector< double >::x ) );
        
        }
        { //::KVector< double >::y
        
            typedef KVector< double > exported_class_t;
            typedef double ( exported_class_t::*y_function_type )(  ) const;
            
            kvector_t_exposer.def( 
                "y"
                , y_function_type( &::KVector< double >::y ) );
        
        }
        { //::KVector< double >::z
        
            typedef KVector< double > exported_class_t;
            typedef double ( exported_class_t::*z_function_type )(  ) const;
            
            kvector_t_exposer.def( 
                "z"
                , z_function_type( &::KVector< double >::z ) );
        
        }
        kvector_t_exposer.staticmethod( "LambdaAlphaPhi" );
        kvector_t_exposer.def( bp::self_ns::str( bp::self ) );
    }

    bp::class_< Layer_wrapper >( "Layer", bp::init< >() )    
        .def( bp::init< Layer const & >(( bp::arg("other") )) )    
        .def( 
            "getMaterial"
            , (::IMaterial const * ( ::Layer::* )(  ) const)(&::Layer::getMaterial)
            , (::IMaterial const * ( Layer_wrapper::* )(  ) const)(&Layer_wrapper::default_getMaterial)
            , bp::return_value_policy< bp::reference_existing_object >() )    
        .def( 
            "setMaterial"
            , (void ( ::Layer::* )( ::IMaterial const * ) )(&::Layer::setMaterial)
            , (void ( Layer_wrapper::* )( ::IMaterial const * ) )(&Layer_wrapper::default_setMaterial)
            , ( bp::arg("p_material") ) )    
        .def( 
            "setMaterial"
            , (void ( ::Layer::* )( ::IMaterial const *,double ) )(&::Layer::setMaterial)
            , (void ( Layer_wrapper::* )( ::IMaterial const *,double ) )(&Layer_wrapper::default_setMaterial)
            , ( bp::arg("p_material"), bp::arg("thickness") ) )    
        .def( bp::self_ns::str( bp::self ) );

}
