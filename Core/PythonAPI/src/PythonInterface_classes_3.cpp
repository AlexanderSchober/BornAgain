// This file has been generated by Py++.

#include "boost/python.hpp"
#include "BasicVector3D.h"
#include "Experiment.h"
#include "FormFactorCylinder.h"
#include "FormFactorFullSphere.h"
#include "FormFactorPyramid.h"
#include "GISASExperiment.h"
#include "HomogeneousMaterial.h"
#include "IClusteredNanoParticles.h"
#include "ICompositeSample.h"
#include "IFormFactor.h"
#include "IInterferenceFunction.h"
#include "InterferenceFunctionNone.h"
#include "InterferenceFunction1DParaCrystal.h"
#include "IMaterial.h"
#include "ISample.h"
#include "ISingleton.h"
#include "Lattice.h"
#include "LatticeBasis.h"
#include "Layer.h"
#include "LayerDecorator.h"
#include "LayerRoughness.h"
#include "MaterialManager.h"
#include "MesoCrystal.h"
#include "MultiLayer.h"
#include "NanoParticle.h"
#include "NanoParticleCrystal.h"
#include "NanoParticleDecoration.h"
#include "OpticalFresnel.h"
#include "ParameterPool.h"
#include "Point3D.h"
#include "PythonOutputData.h"
#include "PythonPlusplusHelper.h"
#include "Transform3D.h"
#include "Units.h"
#include "Types.h"
#include "Vector3D.h"
#include "PythonInterface_classes_3.h"

namespace bp = boost::python;

struct Layer_wrapper : Layer, bp::wrapper< Layer > {

    Layer_wrapper( )
    : Layer( )
      , bp::wrapper< Layer >(){
        // null constructor
    
    }

    Layer_wrapper(::Layer const & other )
    : Layer( boost::ref(other) )
      , bp::wrapper< Layer >(){
        // copy constructor
    
    }

    virtual ::IMaterial const * getMaterial(  ) const  {
        if( bp::override func_getMaterial = this->get_override( "getMaterial" ) )
            return func_getMaterial(  );
        else{
            return this->Layer::getMaterial(  );
        }
    }
    
    ::IMaterial const * default_getMaterial(  ) const  {
        return Layer::getMaterial( );
    }

    virtual void setMaterial( ::IMaterial const * p_material ) {
        if( bp::override func_setMaterial = this->get_override( "setMaterial" ) )
            func_setMaterial( boost::python::ptr(p_material) );
        else{
            this->Layer::setMaterial( boost::python::ptr(p_material) );
        }
    }
    
    void default_setMaterial( ::IMaterial const * p_material ) {
        Layer::setMaterial( boost::python::ptr(p_material) );
    }

    virtual void setMaterial( ::IMaterial const * p_material, double thickness ) {
        if( bp::override func_setMaterial = this->get_override( "setMaterial" ) )
            func_setMaterial( boost::python::ptr(p_material), thickness );
        else{
            this->Layer::setMaterial( boost::python::ptr(p_material), thickness );
        }
    }
    
    void default_setMaterial( ::IMaterial const * p_material, double thickness ) {
        Layer::setMaterial( boost::python::ptr(p_material), thickness );
    }

};

struct NanoParticleCrystal_wrapper : NanoParticleCrystal, bp::wrapper< NanoParticleCrystal > {

    NanoParticleCrystal_wrapper(NanoParticleCrystal const & arg )
    : NanoParticleCrystal( arg )
      , bp::wrapper< NanoParticleCrystal >(){
        // copy constructor
        
    }

    NanoParticleCrystal_wrapper(::NanoParticle const & nano_particle, ::Lattice const & lattice )
    : NanoParticleCrystal( boost::ref(nano_particle), boost::ref(lattice) )
      , bp::wrapper< NanoParticleCrystal >(){
        // constructor
    
    }

    virtual ::IFormFactor * createTotalFormFactor( ::IFormFactor const & meso_crystal_form_factor, ::complex_t ambient_refractive_index ) const {
        bp::override func_createTotalFormFactor = this->get_override( "createTotalFormFactor" );
        return func_createTotalFormFactor( boost::ref(meso_crystal_form_factor), ambient_refractive_index );
    }

    virtual void setAmbientRefractiveIndex( ::complex_t refractive_index ){
        bp::override func_setAmbientRefractiveIndex = this->get_override( "setAmbientRefractiveIndex" );
        func_setAmbientRefractiveIndex( refractive_index );
    }

};

void register_classes_3(){

    { //::KVector< double >
        typedef bp::class_< KVector< double > > kvector_t_exposer_t;
        kvector_t_exposer_t kvector_t_exposer = kvector_t_exposer_t( "kvector_t", bp::init< >() );
        bp::scope kvector_t_scope( kvector_t_exposer );
        kvector_t_exposer.def( bp::init< double, double, double >(( bp::arg("x"), bp::arg("y"), bp::arg("z") )) );
        { //::KVector< double >::LambdaAlphaPhi
        
            typedef KVector< double > exported_class_t;
            typedef ::KVector< double > ( *LambdaAlphaPhi_function_type )( double,double,double );
            
            kvector_t_exposer.def( 
                "LambdaAlphaPhi"
                , LambdaAlphaPhi_function_type( &::KVector< double >::LambdaAlphaPhi )
                , ( bp::arg("lambda"), bp::arg("alpha"), bp::arg("phi") ) );
        
        }
        { //::KVector< double >::mag
        
            typedef KVector< double > exported_class_t;
            typedef double ( exported_class_t::*mag_function_type )(  ) const;
            
            kvector_t_exposer.def( 
                "mag"
                , mag_function_type( &::KVector< double >::mag ) );
        
        }
        { //::KVector< double >::mag2
        
            typedef KVector< double > exported_class_t;
            typedef double ( exported_class_t::*mag2_function_type )(  ) const;
            
            kvector_t_exposer.def( 
                "mag2"
                , mag2_function_type( &::KVector< double >::mag2 ) );
        
        }
        { //::KVector< double >::magxy
        
            typedef KVector< double > exported_class_t;
            typedef double ( exported_class_t::*magxy_function_type )(  ) const;
            
            kvector_t_exposer.def( 
                "magxy"
                , magxy_function_type( &::KVector< double >::magxy ) );
        
        }
        kvector_t_exposer.def( bp::self += bp::self );
        kvector_t_exposer.def( bp::self -= bp::self );
        { //::KVector< double >::operator=
        
            typedef KVector< double > exported_class_t;
            typedef ::KVector< double > & ( exported_class_t::*assign_function_type )( ::KVector< double > const & ) ;
            
            kvector_t_exposer.def( 
                "assign"
                , assign_function_type( &::KVector< double >::operator= )
                , ( bp::arg("other") )
                , bp::return_self< >() );
        
        }
        { //::KVector< double >::setLambdaAlphaPhi
        
            typedef KVector< double > exported_class_t;
            typedef void ( exported_class_t::*setLambdaAlphaPhi_function_type )( double,double,double ) ;
            
            kvector_t_exposer.def( 
                "setLambdaAlphaPhi"
                , setLambdaAlphaPhi_function_type( &::KVector< double >::setLambdaAlphaPhi )
                , ( bp::arg("lambda"), bp::arg("alpha"), bp::arg("phi") ) );
        
        }
        { //::KVector< double >::setMagThetaPhi
        
            typedef KVector< double > exported_class_t;
            typedef void ( exported_class_t::*setMagThetaPhi_function_type )( double,double,double ) ;
            
            kvector_t_exposer.def( 
                "setMagThetaPhi"
                , setMagThetaPhi_function_type( &::KVector< double >::setMagThetaPhi )
                , ( bp::arg("mag"), bp::arg("theta"), bp::arg("phi") ) );
        
        }
        { //::KVector< double >::setXYZ
        
            typedef KVector< double > exported_class_t;
            typedef void ( exported_class_t::*setXYZ_function_type )( double,double,double ) ;
            
            kvector_t_exposer.def( 
                "setXYZ"
                , setXYZ_function_type( &::KVector< double >::setXYZ )
                , ( bp::arg("x"), bp::arg("y"), bp::arg("z") ) );
        
        }
        { //::KVector< double >::x
        
            typedef KVector< double > exported_class_t;
            typedef double ( exported_class_t::*x_function_type )(  ) const;
            
            kvector_t_exposer.def( 
                "x"
                , x_function_type( &::KVector< double >::x ) );
        
        }
        { //::KVector< double >::y
        
            typedef KVector< double > exported_class_t;
            typedef double ( exported_class_t::*y_function_type )(  ) const;
            
            kvector_t_exposer.def( 
                "y"
                , y_function_type( &::KVector< double >::y ) );
        
        }
        { //::KVector< double >::z
        
            typedef KVector< double > exported_class_t;
            typedef double ( exported_class_t::*z_function_type )(  ) const;
            
            kvector_t_exposer.def( 
                "z"
                , z_function_type( &::KVector< double >::z ) );
        
        }
        kvector_t_exposer.staticmethod( "LambdaAlphaPhi" );
        kvector_t_exposer.def( bp::self * bp::self );
        kvector_t_exposer.def( bp::other< double >() * bp::self );
        kvector_t_exposer.def( bp::self + bp::self );
        kvector_t_exposer.def( +bp::self );
        kvector_t_exposer.def( bp::self - bp::self );
        kvector_t_exposer.def( -bp::self );
        kvector_t_exposer.def( bp::self - bp::self );
        kvector_t_exposer.def( bp::self_ns::str( bp::self ) );
    }

    bp::class_< Lattice >( "Lattice", bp::init< >() )    
        .def( bp::init< kvector_t const &, kvector_t const &, kvector_t const & >(( bp::arg("a1"), bp::arg("a2"), bp::arg("a3") )) )    
        .def( 
            "createTrigonalLattice"
            , (::Lattice (*)( double,double ))( &::Lattice::createTrigonalLattice )
            , ( bp::arg("a"), bp::arg("c") ) )    
        .def( 
            "getBasisVectorA"
            , (::kvector_t ( ::Lattice::* )(  ) )( &::Lattice::getBasisVectorA ) )    
        .def( 
            "getBasisVectorB"
            , (::kvector_t ( ::Lattice::* )(  ) )( &::Lattice::getBasisVectorB ) )    
        .def( 
            "getBasisVectorC"
            , (::kvector_t ( ::Lattice::* )(  ) )( &::Lattice::getBasisVectorC ) )    
        .staticmethod( "createTrigonalLattice" );

    bp::class_< NanoParticle, bp::bases< ISample >, boost::noncopyable >( "NanoParticle", bp::init< complex_t, IFormFactor const & >(( bp::arg("refractive_index"), bp::arg("p_form_factor") )) );

    bp::class_< LatticeBasis, bp::bases< NanoParticle >, boost::noncopyable >( "LatticeBasis", bp::init< >() )    
        .def( 
            "addParticle"
            , (void ( ::LatticeBasis::* )( ::NanoParticle const &,::kvector_t ) )( &::LatticeBasis::addParticle )
            , ( bp::arg("particle"), bp::arg("position") ) );

    bp::class_< Layer_wrapper, bp::bases< ISample > >( "Layer", bp::init< >() )    
        .def( bp::init< Layer const & >(( bp::arg("other") )) )    
        .def( 
            "getMaterial"
            , (::IMaterial const * ( ::Layer::* )(  ) const)(&::Layer::getMaterial)
            , (::IMaterial const * ( Layer_wrapper::* )(  ) const)(&Layer_wrapper::default_getMaterial)
            , bp::return_value_policy< bp::reference_existing_object >() )    
        .def( 
            "setMaterial"
            , (void ( ::Layer::* )( ::IMaterial const * ) )(&::Layer::setMaterial)
            , (void ( Layer_wrapper::* )( ::IMaterial const * ) )(&Layer_wrapper::default_setMaterial)
            , ( bp::arg("p_material") ) )    
        .def( 
            "setMaterial"
            , (void ( ::Layer::* )( ::IMaterial const *,double ) )(&::Layer::setMaterial)
            , (void ( Layer_wrapper::* )( ::IMaterial const *,double ) )(&Layer_wrapper::default_setMaterial)
            , ( bp::arg("p_material"), bp::arg("thickness") ) )    
        .def( bp::self_ns::str( bp::self ) );

    bp::class_< LayerDecorator, bp::bases< Layer > >( "LayerDecorator", bp::init< Layer const &, NanoParticleDecoration const & >(( bp::arg("layer"), bp::arg("decoration") )) );

    { //::LayerRoughness
        typedef bp::class_< LayerRoughness > LayerRoughness_exposer_t;
        LayerRoughness_exposer_t LayerRoughness_exposer = LayerRoughness_exposer_t( "LayerRoughness", bp::init< >() );
        bp::scope LayerRoughness_scope( LayerRoughness_exposer );
        LayerRoughness_exposer.def( bp::init< double, double, double >(( bp::arg("sigma"), bp::arg("hurstParameter"), bp::arg("latteralCorrLength") )) );
        LayerRoughness_exposer.def( bp::init< LayerRoughness const & >(( bp::arg("other") )) );
        { //::LayerRoughness::getHurstParameter
        
            typedef double ( ::LayerRoughness::*getHurstParameter_function_type )(  ) const;
            
            LayerRoughness_exposer.def( 
                "getHurstParameter"
                , getHurstParameter_function_type( &::LayerRoughness::getHurstParameter ) );
        
        }
        { //::LayerRoughness::getLatteralCorrLength
        
            typedef double ( ::LayerRoughness::*getLatteralCorrLength_function_type )(  ) const;
            
            LayerRoughness_exposer.def( 
                "getLatteralCorrLength"
                , getLatteralCorrLength_function_type( &::LayerRoughness::getLatteralCorrLength ) );
        
        }
        { //::LayerRoughness::getSigma
        
            typedef double ( ::LayerRoughness::*getSigma_function_type )(  ) const;
            
            LayerRoughness_exposer.def( 
                "getSigma"
                , getSigma_function_type( &::LayerRoughness::getSigma ) );
        
        }
        { //::LayerRoughness::operator=
        
            typedef ::LayerRoughness & ( ::LayerRoughness::*assign_function_type )( ::LayerRoughness const & ) ;
            
            LayerRoughness_exposer.def( 
                "assign"
                , assign_function_type( &::LayerRoughness::operator= )
                , ( bp::arg("other") )
                , bp::return_self< >() );
        
        }
        { //::LayerRoughness::setHurstParameter
        
            typedef void ( ::LayerRoughness::*setHurstParameter_function_type )( double ) ;
            
            LayerRoughness_exposer.def( 
                "setHurstParameter"
                , setHurstParameter_function_type( &::LayerRoughness::setHurstParameter )
                , ( bp::arg("hurstParameter") ) );
        
        }
        { //::LayerRoughness::setLatteralCorrLength
        
            typedef void ( ::LayerRoughness::*setLatteralCorrLength_function_type )( double ) ;
            
            LayerRoughness_exposer.def( 
                "setLatteralCorrLength"
                , setLatteralCorrLength_function_type( &::LayerRoughness::setLatteralCorrLength )
                , ( bp::arg("latteralCorrLength") ) );
        
        }
        { //::LayerRoughness::setSigma
        
            typedef void ( ::LayerRoughness::*setSigma_function_type )( double ) ;
            
            LayerRoughness_exposer.def( 
                "setSigma"
                , setSigma_function_type( &::LayerRoughness::setSigma )
                , ( bp::arg("sigma") ) );
        
        }
        LayerRoughness_exposer.def( bp::self_ns::str( bp::self ) );
    }

    bp::class_< MaterialManager, bp::bases< ISingleton< MaterialManager > >, boost::noncopyable >( "MaterialManager", bp::no_init )    
        .def( 
            "addHomogeneousMaterial"
            , (::IMaterial const * ( ::MaterialManager::* )( ::std::string const &,::complex_t ) )( &::MaterialManager::addHomogeneousMaterial )
            , ( bp::arg("name"), bp::arg("refractive_index") )
            , bp::return_internal_reference< >() )    
        .def( 
            "clear"
            , (void ( ::MaterialManager::* )(  ) )( &::MaterialManager::clear ) )    
        .def( 
            "getMaterial"
            , (::IMaterial const * ( ::MaterialManager::* )( ::std::string const & ) )( &::MaterialManager::getMaterial )
            , ( bp::arg("name") )
            , bp::return_internal_reference< >() )    
        .def( bp::self_ns::str( bp::self ) );

    bp::class_< MesoCrystal, bp::bases< NanoParticle >, boost::noncopyable >( "MesoCrystal", bp::init< IClusteredNanoParticles const &, IFormFactor & >(( bp::arg("nano_particle_structure"), bp::arg("form_factor") )) );

    bp::class_< MultiLayer, bp::bases< ICompositeSample >, boost::noncopyable >( "MultiLayer", bp::init< >() )    
        .def( 
            "addLayer"
            , (void ( ::MultiLayer::* )( ::Layer const & ) )( &::MultiLayer::addLayer )
            , ( bp::arg("p_child") ) )    
        .def( 
            "addLayerWithTopRoughness"
            , (void ( ::MultiLayer::* )( ::Layer const &,::LayerRoughness const & ) )( &::MultiLayer::addLayerWithTopRoughness )
            , ( bp::arg("layer"), bp::arg("roughness") ) )    
        .def( 
            "getCrossCorrLength"
            , (double ( ::MultiLayer::* )(  ) const)( &::MultiLayer::getCrossCorrLength ) )    
        .def( 
            "getNumberOfLayers"
            , (::size_t ( ::MultiLayer::* )(  ) const)( &::MultiLayer::getNumberOfLayers ) )    
        .def( 
            "setCrossCorrLength"
            , (void ( ::MultiLayer::* )( double ) )( &::MultiLayer::setCrossCorrLength )
            , ( bp::arg("crossCorrLength") ) )    
        .def( bp::self_ns::str( bp::self ) );

    bp::class_< NanoParticleCrystal_wrapper, bp::bases< IClusteredNanoParticles > >( "NanoParticleCrystal", bp::init< NanoParticle const &, Lattice const & >(( bp::arg("nano_particle"), bp::arg("lattice") )) )    
        .def( 
            "createTotalFormFactor"
            , bp::pure_virtual( (::IFormFactor * ( ::IClusteredNanoParticles::* )( ::IFormFactor const &,::complex_t ) const)(&::IClusteredNanoParticles::createTotalFormFactor) )
            , ( bp::arg("meso_crystal_form_factor"), bp::arg("ambient_refractive_index") )
            , bp::return_value_policy< bp::manage_new_object >() )    
        .def( 
            "setAmbientRefractiveIndex"
            , bp::pure_virtual( (void ( ::IClusteredNanoParticles::* )( ::complex_t ) )(&::IClusteredNanoParticles::setAmbientRefractiveIndex) )
            , ( bp::arg("refractive_index") ) );

    bp::class_< NanoParticleDecoration, boost::noncopyable >( "NanoParticleDecoration", bp::init< >() )    
        .def( 
            "addInterferenceFunction"
            , (void ( ::NanoParticleDecoration::* )( ::IInterferenceFunction const & ) )( &::NanoParticleDecoration::addInterferenceFunction )
            , ( bp::arg("interference_function") ) )    
        .def( 
            "addNanoParticle"
            , (void ( ::NanoParticleDecoration::* )( ::NanoParticle const &,::Geometry::Transform3D const &,double,double ) )( &::NanoParticleDecoration::addNanoParticle )
            , ( bp::arg("p_particle"), bp::arg("transform"), bp::arg("depth")=0, bp::arg("abundance")=1.0e+0 ) )    
        .def( 
            "addNanoParticle"
            , (void ( ::NanoParticleDecoration::* )( ::NanoParticle const &,double,double ) )( &::NanoParticleDecoration::addNanoParticle )
            , ( bp::arg("p_particle"), bp::arg("depth")=0.0, bp::arg("abundance")=1.0e+0 ) );

    { //::OpticalFresnel
        typedef bp::class_< OpticalFresnel > OpticalFresnel_exposer_t;
        OpticalFresnel_exposer_t OpticalFresnel_exposer = OpticalFresnel_exposer_t( "OpticalFresnel", bp::init< >() );
        bp::scope OpticalFresnel_scope( OpticalFresnel_exposer );
        bp::class_< OpticalFresnel::FresnelCoeff >( "FresnelCoeff", bp::init< >() )    
            .def( bp::self == bp::self )    
            .def_readwrite( "R", &OpticalFresnel::FresnelCoeff::R )    
            .def_readwrite( "T", &OpticalFresnel::FresnelCoeff::T )    
            .def_readwrite( "X", &OpticalFresnel::FresnelCoeff::X )    
            .def_readwrite( "kz", &OpticalFresnel::FresnelCoeff::kz )    
            .def_readwrite( "r", &OpticalFresnel::FresnelCoeff::r )    
            .def_readwrite( "rb", &OpticalFresnel::FresnelCoeff::rb )    
            .def_readwrite( "t", &OpticalFresnel::FresnelCoeff::t )    
            .def_readwrite( "tb", &OpticalFresnel::FresnelCoeff::tb );
        bp::class_< OpticalFresnel::MultiLayerCoeff >( "MultiLayerCoeff" )    
            .def( 
                "__getitem__"
                , (::OpticalFresnel::FresnelCoeff & ( ::OpticalFresnel::MultiLayerCoeff::* )( ::size_t ) )( &::OpticalFresnel::MultiLayerCoeff::operator[] )
                , ( bp::arg("i") )
                , bp::return_internal_reference< >() )    
            .def( 
                "size"
                , (::size_t ( ::OpticalFresnel::MultiLayerCoeff::* )(  ) const)( &::OpticalFresnel::MultiLayerCoeff::size ) )    
            .def_readwrite( "m_data", &OpticalFresnel::MultiLayerCoeff::m_data );
        { //::OpticalFresnel::execute
        
            typedef int ( ::OpticalFresnel::*execute_function_type )( ::MultiLayer const &,::kvector_t const &,::std::vector< OpticalFresnel::FresnelCoeff > &,bool ) ;
            
            OpticalFresnel_exposer.def( 
                "execute"
                , execute_function_type( &::OpticalFresnel::execute )
                , ( bp::arg("sample"), bp::arg("k"), bp::arg("coeff"), bp::arg("useRoughness")=(bool)(false) ) );
        
        }
        { //::OpticalFresnel::execute
        
            typedef int ( ::OpticalFresnel::*execute_function_type )( ::MultiLayer const &,::kvector_t const &,::OpticalFresnel::MultiLayerCoeff &,bool ) ;
            
            OpticalFresnel_exposer.def( 
                "execute"
                , execute_function_type( &::OpticalFresnel::execute )
                , ( bp::arg("sample"), bp::arg("k"), bp::arg("coeff"), bp::arg("useRoughness")=(bool)(false) ) );
        
        }
    }

    { //::ParameterPool
        typedef bp::class_< ParameterPool, boost::noncopyable > ParameterPool_exposer_t;
        ParameterPool_exposer_t ParameterPool_exposer = ParameterPool_exposer_t( "ParameterPool", bp::init< >() );
        bp::scope ParameterPool_scope( ParameterPool_exposer );
        bp::class_< ParameterPool::RealPar >( "RealPar", bp::init< double * >(( bp::arg("par") )) )    
            .def( 
                "checkNull"
                , (void ( ::ParameterPool::RealPar::* )(  ) const)( &::ParameterPool::RealPar::checkNull ) )    
            .def( 
                "getValue"
                , (double ( ::ParameterPool::RealPar::* )(  ) const)( &::ParameterPool::RealPar::getValue ) )    
            .def( 
                "isNull"
                , (bool ( ::ParameterPool::RealPar::* )(  ) )( &::ParameterPool::RealPar::isNull ) )    
            .def( 
                "setValue"
                , (void ( ::ParameterPool::RealPar::* )( double ) )( &::ParameterPool::RealPar::setValue )
                , ( bp::arg("value") ) )    
            .def( bp::self_ns::str( bp::self ) );
        { //::ParameterPool::addParameter
        
            typedef bool ( ::ParameterPool::*addParameter_function_type )( ::std::string,::ParameterPool::RealPar ) ;
            
            ParameterPool_exposer.def( 
                "addParameter"
                , addParameter_function_type( &::ParameterPool::addParameter )
                , ( bp::arg("name"), bp::arg("par") ) );
        
        }
        { //::ParameterPool::begin
        
            typedef ::std::_Rb_tree_iterator< std::pair< std::string const, ParameterPool::RealPar > > ( ::ParameterPool::*begin_function_type )(  ) ;
            
            ParameterPool_exposer.def( 
                "begin"
                , begin_function_type( &::ParameterPool::begin ) );
        
        }
        { //::ParameterPool::begin
        
            typedef ::std::_Rb_tree_const_iterator< std::pair< std::string const, ParameterPool::RealPar > > ( ::ParameterPool::*begin_function_type )(  ) const;
            
            ParameterPool_exposer.def( 
                "begin"
                , begin_function_type( &::ParameterPool::begin ) );
        
        }
        { //::ParameterPool::clear
        
            typedef void ( ::ParameterPool::*clear_function_type )(  ) ;
            
            ParameterPool_exposer.def( 
                "clear"
                , clear_function_type( &::ParameterPool::clear ) );
        
        }
        { //::ParameterPool::clone
        
            typedef ::ParameterPool * ( ::ParameterPool::*clone_function_type )(  ) ;
            
            ParameterPool_exposer.def( 
                "clone"
                , clone_function_type( &::ParameterPool::clone )
                , bp::return_value_policy< bp::reference_existing_object >() );
        
        }
        { //::ParameterPool::cloneWithPrefix
        
            typedef ::ParameterPool * ( ::ParameterPool::*cloneWithPrefix_function_type )( ::std::string ) ;
            
            ParameterPool_exposer.def( 
                "cloneWithPrefix"
                , cloneWithPrefix_function_type( &::ParameterPool::cloneWithPrefix )
                , ( bp::arg("prefix") )
                , bp::return_value_policy< bp::manage_new_object >() );
        
        }
        { //::ParameterPool::copyToExternalPool
        
            typedef void ( ::ParameterPool::*copyToExternalPool_function_type )( ::std::string,::ParameterPool * ) ;
            
            ParameterPool_exposer.def( 
                "copyToExternalPool"
                , copyToExternalPool_function_type( &::ParameterPool::copyToExternalPool )
                , ( bp::arg("prefix"), bp::arg("external_pool") ) );
        
        }
        { //::ParameterPool::end
        
            typedef ::std::_Rb_tree_iterator< std::pair< std::string const, ParameterPool::RealPar > > ( ::ParameterPool::*end_function_type )(  ) ;
            
            ParameterPool_exposer.def( 
                "end"
                , end_function_type( &::ParameterPool::end ) );
        
        }
        { //::ParameterPool::end
        
            typedef ::std::_Rb_tree_const_iterator< std::pair< std::string const, ParameterPool::RealPar > > ( ::ParameterPool::*end_function_type )(  ) const;
            
            ParameterPool_exposer.def( 
                "end"
                , end_function_type( &::ParameterPool::end ) );
        
        }
        { //::ParameterPool::getParameter
        
            typedef ::ParameterPool::RealPar ( ::ParameterPool::*getParameter_function_type )( ::std::string ) const;
            
            ParameterPool_exposer.def( 
                "getParameter"
                , getParameter_function_type( &::ParameterPool::getParameter )
                , ( bp::arg("name") ) );
        
        }
        { //::ParameterPool::registerParameter
        
            typedef bool ( ::ParameterPool::*registerParameter_function_type )( ::std::string,double * ) ;
            
            ParameterPool_exposer.def( 
                "registerParameter"
                , registerParameter_function_type( &::ParameterPool::registerParameter )
                , ( bp::arg("name"), bp::arg("parpointer") ) );
        
        }
        { //::ParameterPool::size
        
            typedef ::size_t ( ::ParameterPool::*size_function_type )(  ) const;
            
            ParameterPool_exposer.def( 
                "size"
                , size_function_type( &::ParameterPool::size ) );
        
        }
        ParameterPool_exposer.def( bp::self_ns::str( bp::self ) );
    }

}
