// This file has been generated by Py++.

// ************************************************************************** //
//
//  BornAgain: simulate and fit scattering at grazing incidence
//
//! @file      Automatically generated boost::python code for BornAgain Python bindings
//! @brief     Automatically generated boost::python code for BornAgain Python bindings
//!
//! @homepage  http://bornagainproject.org
//! @license   GNU General Public License v3 or higher (see COPYING)
//! @copyright Forschungszentrum Juelich GmbH 2015
//! @authors   Scientific Computing Group at MLZ Garching
//! @authors   C. Durniak, M. Ganeva, G. Pospelov, W. Van Herck, J. Wuttke
//
// ************************************************************************** //

#include "Macros.h"
GCC_DIAG_OFF(unused-parameter)
GCC_DIAG_OFF(missing-field-initializers)
#include "boost/python.hpp"
GCC_DIAG_ON(unused-parameter)
GCC_DIAG_ON(missing-field-initializers)
#include "PythonCoreList.h"
#include "AttLimits.pypp.h"

namespace bp = boost::python;

void register_AttLimits_class(){

    { //::AttLimits
        typedef bp::class_< AttLimits > AttLimits_exposer_t;
        AttLimits_exposer_t AttLimits_exposer = AttLimits_exposer_t( "AttLimits", "", bp::init< >("") );
        bp::scope AttLimits_scope( AttLimits_exposer );
        { //::AttLimits::fixed
        
            typedef ::AttLimits ( *fixed_function_type )(  );
            
            AttLimits_exposer.def( 
                "fixed"
                , fixed_function_type( &::AttLimits::fixed )
                , "    //! Creates a fixed value object" );
        
        }
        { //::AttLimits::getLowerLimit
        
            typedef double ( ::AttLimits::*getLowerLimit_function_type)(  ) const;
            
            AttLimits_exposer.def( 
                "getLowerLimit"
                , getLowerLimit_function_type( &::AttLimits::getLowerLimit )
                , "    //! Returns lower limit" );
        
        }
        { //::AttLimits::getUpperLimit
        
            typedef double ( ::AttLimits::*getUpperLimit_function_type)(  ) const;
            
            AttLimits_exposer.def( 
                "getUpperLimit"
                , getUpperLimit_function_type( &::AttLimits::getUpperLimit )
                , "    //! Returns upper limit" );
        
        }
        { //::AttLimits::hasLowerAndUpperLimits
        
            typedef bool ( ::AttLimits::*hasLowerAndUpperLimits_function_type)(  ) const;
            
            AttLimits_exposer.def( 
                "hasLowerAndUpperLimits"
                , hasLowerAndUpperLimits_function_type( &::AttLimits::hasLowerAndUpperLimits )
                , "    //! if has lower and upper limit" );
        
        }
        { //::AttLimits::hasLowerLimit
        
            typedef bool ( ::AttLimits::*hasLowerLimit_function_type)(  ) const;
            
            AttLimits_exposer.def( 
                "hasLowerLimit"
                , hasLowerLimit_function_type( &::AttLimits::hasLowerLimit )
                , "    //! if has lower limit" );
        
        }
        { //::AttLimits::hasUpperLimit
        
            typedef bool ( ::AttLimits::*hasUpperLimit_function_type)(  ) const;
            
            AttLimits_exposer.def( 
                "hasUpperLimit"
                , hasUpperLimit_function_type( &::AttLimits::hasUpperLimit )
                , "    //! if has upper limit" );
        
        }
        { //::AttLimits::isFixed
        
            typedef bool ( ::AttLimits::*isFixed_function_type)(  ) const;
            
            AttLimits_exposer.def( 
                "isFixed"
                , isFixed_function_type( &::AttLimits::isFixed )
                , "    //! if object is fixed at some value" );
        
        }
        { //::AttLimits::isInRange
        
            typedef bool ( ::AttLimits::*isInRange_function_type)( double ) const;
            
            AttLimits_exposer.def( 
                "isInRange"
                , isInRange_function_type( &::AttLimits::isInRange )
                , ( bp::arg("value") )
                , "" );
        
        }
        { //::AttLimits::limited
        
            typedef ::AttLimits ( *limited_function_type )( double,double );
            
            AttLimits_exposer.def( 
                "limited"
                , limited_function_type( &::AttLimits::limited )
                , ( bp::arg("left_bound_value"), bp::arg("right_bound_value") )
                , "    //! Creates an object bounded from the left and right" );
        
        }
        { //::AttLimits::limitless
        
            typedef ::AttLimits ( *limitless_function_type )(  );
            
            AttLimits_exposer.def( 
                "limitless"
                , limitless_function_type( &::AttLimits::limitless )
                , "    //! Creates an object withoud bounds (default)" );
        
        }
        { //::AttLimits::lowerLimited
        
            typedef ::AttLimits ( *lowerLimited_function_type )( double );
            
            AttLimits_exposer.def( 
                "lowerLimited"
                , lowerLimited_function_type( &::AttLimits::lowerLimited )
                , ( bp::arg("bound_value") )
                , "    //! Creates an object bounded from the left" );
        
        }
        { //::AttLimits::n_positive
        
            typedef ::AttLimits ( *n_positive_function_type )(  );
            
            AttLimits_exposer.def( 
                "n_positive"
                , n_positive_function_type( &::AttLimits::n_positive )
                , "    //! Creates an object which can have only positive values with 0.0 included" );
        
        }
        AttLimits_exposer.def( bp::self != bp::self );
        AttLimits_exposer.def( bp::self == bp::self );
        { //::AttLimits::positive
        
            typedef ::AttLimits ( *positive_function_type )(  );
            
            AttLimits_exposer.def( 
                "positive"
                , positive_function_type( &::AttLimits::positive )
                , "    //! Creates an object which can have only positive values (>0.0, zero is not included)" );
        
        }
        { //::AttLimits::removeLimits
        
            typedef void ( ::AttLimits::*removeLimits_function_type)(  ) ;
            
            AttLimits_exposer.def( 
                "removeLimits"
                , removeLimits_function_type( &::AttLimits::removeLimits )
                , "    //! remove limits" );
        
        }
        { //::AttLimits::removeLowerLimit
        
            typedef void ( ::AttLimits::*removeLowerLimit_function_type)(  ) ;
            
            AttLimits_exposer.def( 
                "removeLowerLimit"
                , removeLowerLimit_function_type( &::AttLimits::removeLowerLimit )
                , "    //! remove lower limit" );
        
        }
        { //::AttLimits::removeUpperLimit
        
            typedef void ( ::AttLimits::*removeUpperLimit_function_type)(  ) ;
            
            AttLimits_exposer.def( 
                "removeUpperLimit"
                , removeUpperLimit_function_type( &::AttLimits::removeUpperLimit )
                , "    //! remove upper limit" );
        
        }
        { //::AttLimits::setFixed
        
            typedef void ( ::AttLimits::*setFixed_function_type)( bool ) ;
            
            AttLimits_exposer.def( 
                "setFixed"
                , setFixed_function_type( &::AttLimits::setFixed )
                , ( bp::arg("is_fixed") )
                , "    //! Sets object fixed" );
        
        }
        { //::AttLimits::setLimits
        
            typedef void ( ::AttLimits::*setLimits_function_type)( double,double ) ;
            
            AttLimits_exposer.def( 
                "setLimits"
                , setLimits_function_type( &::AttLimits::setLimits )
                , ( bp::arg("xmin"), bp::arg("xmax") )
                , "    //! Sets lower and upper limits" );
        
        }
        { //::AttLimits::setLowerLimit
        
            typedef void ( ::AttLimits::*setLowerLimit_function_type)( double ) ;
            
            AttLimits_exposer.def( 
                "setLowerLimit"
                , setLowerLimit_function_type( &::AttLimits::setLowerLimit )
                , ( bp::arg("value") )
                , "    //! Sets lower limit" );
        
        }
        { //::AttLimits::setUpperLimit
        
            typedef void ( ::AttLimits::*setUpperLimit_function_type)( double ) ;
            
            AttLimits_exposer.def( 
                "setUpperLimit"
                , setUpperLimit_function_type( &::AttLimits::setUpperLimit )
                , ( bp::arg("value") )
                , "    //! Sets upper limit" );
        
        }
        { //::AttLimits::upperLimited
        
            typedef ::AttLimits ( *upperLimited_function_type )( double );
            
            AttLimits_exposer.def( 
                "upperLimited"
                , upperLimited_function_type( &::AttLimits::upperLimited )
                , ( bp::arg("bound_value") )
                , "    //! Creates an object bounded from the right" );
        
        }
        AttLimits_exposer.staticmethod( "fixed" );
        AttLimits_exposer.staticmethod( "limited" );
        AttLimits_exposer.staticmethod( "limitless" );
        AttLimits_exposer.staticmethod( "lowerLimited" );
        AttLimits_exposer.staticmethod( "n_positive" );
        AttLimits_exposer.staticmethod( "positive" );
        AttLimits_exposer.staticmethod( "upperLimited" );
    }

}
