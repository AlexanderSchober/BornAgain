// This file has been generated by Py++.

// BornAgain: simulate and fit scattering at grazing incidence
//! @brief Automatically generated boost::python code for PythonCoreAPI

#include "Macros.h"
GCC_DIAG_OFF(unused-parameter)
GCC_DIAG_OFF(missing-field-initializers)
#include "boost/python.hpp"
GCC_DIAG_ON(unused-parameter)
GCC_DIAG_ON(missing-field-initializers)
#include "PythonCoreList.h"
#include "AngleBinAxis.pypp.h"

namespace bp = boost::python;

struct AngleBinAxis_wrapper : AngleBinAxis, bp::wrapper< AngleBinAxis > {

    AngleBinAxis_wrapper(AngleBinAxis const & arg )
    : AngleBinAxis( arg )
      , bp::wrapper< AngleBinAxis >(){
        // copy constructor
        
    }

    AngleBinAxis_wrapper(::std::string name, ::std::size_t nbins, double start, double end )
    : AngleBinAxis( name, nbins, start, end )
      , bp::wrapper< AngleBinAxis >(){
        // constructor
    
    }

    virtual ::AngleBinAxis * clone(  ) const  {
        if( bp::override func_clone = this->get_override( "clone" ) )
            return func_clone(  );
        else
            return this->AngleBinAxis::clone(  );
    }
    
    
    ::AngleBinAxis * default_clone(  ) const  {
        return AngleBinAxis::clone( );
    }

    virtual ::std::size_t findClosestIndex( double value ) const  {
        if( bp::override func_findClosestIndex = this->get_override( "findClosestIndex" ) )
            return func_findClosestIndex( value );
        else
            return this->AngleBinAxis::findClosestIndex( value );
    }
    
    
    ::std::size_t default_findClosestIndex( double value ) const  {
        return AngleBinAxis::findClosestIndex( value );
    }

    virtual ::Bin1D getBin( ::std::size_t index ) const  {
        if( bp::override func_getBin = this->get_override( "getBin" ) )
            return func_getBin( index );
        else
            return this->AngleBinAxis::getBin( index );
    }
    
    
    ::Bin1D default_getBin( ::std::size_t index ) const  {
        return AngleBinAxis::getBin( index );
    }

    virtual double getMax(  ) const  {
        if( bp::override func_getMax = this->get_override( "getMax" ) )
            return func_getMax(  );
        else
            return this->AngleBinAxis::getMax(  );
    }
    
    
    double default_getMax(  ) const  {
        return AngleBinAxis::getMax( );
    }

    virtual double getMin(  ) const  {
        if( bp::override func_getMin = this->get_override( "getMin" ) )
            return func_getMin(  );
        else
            return this->AngleBinAxis::getMin(  );
    }
    
    
    double default_getMin(  ) const  {
        return AngleBinAxis::getMin( );
    }

    virtual ::std::size_t getSize(  ) const  {
        if( bp::override func_getSize = this->get_override( "getSize" ) )
            return func_getSize(  );
        else
            return this->AngleBinAxis::getSize(  );
    }
    
    
    ::std::size_t default_getSize(  ) const  {
        return AngleBinAxis::getSize( );
    }

    virtual double operator[]( ::std::size_t index ) const  {
        if( bp::override func___getitem__ = this->get_override( "__getitem__" ) )
            return func___getitem__( index );
        else
            return this->AngleBinAxis::operator[]( index );
    }
    
    
    double default___getitem__( ::std::size_t index ) const  {
        return AngleBinAxis::operator[]( index );
    }

    virtual ::IAxis * createDoubleBinSize(  ) const  {
        if( bp::override func_createDoubleBinSize = this->get_override( "createDoubleBinSize" ) )
            return func_createDoubleBinSize(  );
        else
            return this->IAxis::createDoubleBinSize(  );
    }
    
    
    ::IAxis * default_createDoubleBinSize(  ) const  {
        return IAxis::createDoubleBinSize( );
    }

    virtual ::std::vector< double > getBinBoundaries(  ) const  {
        if( bp::override func_getBinBoundaries = this->get_override( "getBinBoundaries" ) )
            return func_getBinBoundaries(  );
        else
            return this->IAxis::getBinBoundaries(  );
    }
    
    
    ::std::vector< double > default_getBinBoundaries(  ) const  {
        return IAxis::getBinBoundaries( );
    }

    virtual ::std::vector< double > getBinCenters(  ) const  {
        if( bp::override func_getBinCenters = this->get_override( "getBinCenters" ) )
            return func_getBinCenters(  );
        else
            return this->IAxis::getBinCenters(  );
    }
    
    
    ::std::vector< double > default_getBinCenters(  ) const  {
        return IAxis::getBinCenters( );
    }

};

void register_AngleBinAxis_class(){

    { //::AngleBinAxis
        typedef bp::class_< AngleBinAxis_wrapper, bp::bases< IAxis > > AngleBinAxis_exposer_t;
        AngleBinAxis_exposer_t AngleBinAxis_exposer = AngleBinAxis_exposer_t( "AngleBinAxis", bp::init< std::string, std::size_t, double, double >(( bp::arg("name"), bp::arg("nbins"), bp::arg("start"), bp::arg("end") )) );
        bp::scope AngleBinAxis_scope( AngleBinAxis_exposer );
        { //::AngleBinAxis::clone
        
            typedef ::AngleBinAxis * ( ::AngleBinAxis::*clone_function_type )(  ) const;
            typedef ::AngleBinAxis * ( AngleBinAxis_wrapper::*default_clone_function_type )(  ) const;
            
            AngleBinAxis_exposer.def( 
                "clone"
                , clone_function_type(&::AngleBinAxis::clone)
                , default_clone_function_type(&AngleBinAxis_wrapper::default_clone)
                , bp::return_value_policy< bp::manage_new_object >() );
        
        }
        { //::AngleBinAxis::createIsGISAXSAxis
        
            typedef ::AngleBinAxis * ( *createIsGISAXSAxis_function_type )( ::std::string,::std::size_t,double,double );
            
            AngleBinAxis_exposer.def( 
                "createIsGISAXSAxis"
                , createIsGISAXSAxis_function_type( &::AngleBinAxis::createIsGISAXSAxis )
                , ( bp::arg("name"), bp::arg("nbins"), bp::arg("start"), bp::arg("end") )
                , bp::return_value_policy< bp::manage_new_object >() );
        
        }
        { //::AngleBinAxis::findClosestIndex
        
            typedef ::std::size_t ( ::AngleBinAxis::*findClosestIndex_function_type )( double ) const;
            typedef ::std::size_t ( AngleBinAxis_wrapper::*default_findClosestIndex_function_type )( double ) const;
            
            AngleBinAxis_exposer.def( 
                "findClosestIndex"
                , findClosestIndex_function_type(&::AngleBinAxis::findClosestIndex)
                , default_findClosestIndex_function_type(&AngleBinAxis_wrapper::default_findClosestIndex)
                , ( bp::arg("value") ) );
        
        }
        { //::AngleBinAxis::getBin
        
            typedef ::Bin1D ( ::AngleBinAxis::*getBin_function_type )( ::std::size_t ) const;
            typedef ::Bin1D ( AngleBinAxis_wrapper::*default_getBin_function_type )( ::std::size_t ) const;
            
            AngleBinAxis_exposer.def( 
                "getBin"
                , getBin_function_type(&::AngleBinAxis::getBin)
                , default_getBin_function_type(&AngleBinAxis_wrapper::default_getBin)
                , ( bp::arg("index") ) );
        
        }
        { //::AngleBinAxis::getMax
        
            typedef double ( ::AngleBinAxis::*getMax_function_type )(  ) const;
            typedef double ( AngleBinAxis_wrapper::*default_getMax_function_type )(  ) const;
            
            AngleBinAxis_exposer.def( 
                "getMax"
                , getMax_function_type(&::AngleBinAxis::getMax)
                , default_getMax_function_type(&AngleBinAxis_wrapper::default_getMax) );
        
        }
        { //::AngleBinAxis::getMin
        
            typedef double ( ::AngleBinAxis::*getMin_function_type )(  ) const;
            typedef double ( AngleBinAxis_wrapper::*default_getMin_function_type )(  ) const;
            
            AngleBinAxis_exposer.def( 
                "getMin"
                , getMin_function_type(&::AngleBinAxis::getMin)
                , default_getMin_function_type(&AngleBinAxis_wrapper::default_getMin) );
        
        }
        { //::AngleBinAxis::getSize
        
            typedef ::std::size_t ( ::AngleBinAxis::*getSize_function_type )(  ) const;
            typedef ::std::size_t ( AngleBinAxis_wrapper::*default_getSize_function_type )(  ) const;
            
            AngleBinAxis_exposer.def( 
                "getSize"
                , getSize_function_type(&::AngleBinAxis::getSize)
                , default_getSize_function_type(&AngleBinAxis_wrapper::default_getSize) );
        
        }
        { //::AngleBinAxis::operator[]
        
            typedef double ( ::AngleBinAxis::*__getitem___function_type )( ::std::size_t ) const;
            typedef double ( AngleBinAxis_wrapper::*default___getitem___function_type )( ::std::size_t ) const;
            
            AngleBinAxis_exposer.def( 
                "__getitem__"
                , __getitem___function_type(&::AngleBinAxis::operator[])
                , default___getitem___function_type(&AngleBinAxis_wrapper::default___getitem__)
                , ( bp::arg("index") ) );
        
        }
        { //::IAxis::createDoubleBinSize
        
            typedef ::IAxis * ( ::IAxis::*createDoubleBinSize_function_type )(  ) const;
            typedef ::IAxis * ( AngleBinAxis_wrapper::*default_createDoubleBinSize_function_type )(  ) const;
            
            AngleBinAxis_exposer.def( 
                "createDoubleBinSize"
                , createDoubleBinSize_function_type(&::IAxis::createDoubleBinSize)
                , default_createDoubleBinSize_function_type(&AngleBinAxis_wrapper::default_createDoubleBinSize)
                , bp::return_value_policy< bp::manage_new_object >() );
        
        }
        { //::IAxis::getBinBoundaries
        
            typedef ::std::vector< double > ( ::IAxis::*getBinBoundaries_function_type )(  ) const;
            typedef ::std::vector< double > ( AngleBinAxis_wrapper::*default_getBinBoundaries_function_type )(  ) const;
            
            AngleBinAxis_exposer.def( 
                "getBinBoundaries"
                , getBinBoundaries_function_type(&::IAxis::getBinBoundaries)
                , default_getBinBoundaries_function_type(&AngleBinAxis_wrapper::default_getBinBoundaries) );
        
        }
        { //::IAxis::getBinCenters
        
            typedef ::std::vector< double > ( ::IAxis::*getBinCenters_function_type )(  ) const;
            typedef ::std::vector< double > ( AngleBinAxis_wrapper::*default_getBinCenters_function_type )(  ) const;
            
            AngleBinAxis_exposer.def( 
                "getBinCenters"
                , getBinCenters_function_type(&::IAxis::getBinCenters)
                , default_getBinCenters_function_type(&AngleBinAxis_wrapper::default_getBinCenters) );
        
        }
        AngleBinAxis_exposer.staticmethod( "createIsGISAXSAxis" );
    }

}
