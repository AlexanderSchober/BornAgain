// This file has been generated by Py++.

// ************************************************************************** //
//
//  BornAgain: simulate and fit scattering at grazing incidence
//
//! @file      Automatically generated boost::python code for BornAgain Python bindings
//! @brief     Automatically generated boost::python code for BornAgain Python bindings
//!
//! @homepage  http://bornagainproject.org
//! @license   GNU General Public License v3 or higher (see COPYING)
//! @copyright Forschungszentrum Juelich GmbH 2015
//! @authors   Scientific Computing Group at MLZ Garching
//! @authors   C. Durniak, M. Ganeva, G. Pospelov, W. Van Herck, J. Wuttke
//
// ************************************************************************** //

#include "Macros.h"
GCC_DIAG_OFF(unused-parameter)
GCC_DIAG_OFF(missing-field-initializers)
#include "boost/python.hpp"
GCC_DIAG_ON(unused-parameter)
GCC_DIAG_ON(missing-field-initializers)
#include "__call_policies.pypp.hpp"
#include "__convenience.pypp.hpp"
#include "PythonCoreList.h"
#include "GISASSimulation.pypp.h"

namespace bp = boost::python;

struct GISASSimulation_wrapper : GISASSimulation, bp::wrapper< GISASSimulation > {

    GISASSimulation_wrapper( )
    : GISASSimulation( )
      , bp::wrapper< GISASSimulation >(){
        // null constructor
    m_pyobj = 0;
    }

    virtual ::GISASSimulation * clone(  ) const  {
        if( bp::override func_clone = this->get_override( "clone" ) )
            return func_clone(  );
        else{
            return this->GISASSimulation::clone(  );
        }
    }
    
    ::GISASSimulation * default_clone(  ) const  {
        return GISASSimulation::clone( );
    }

    virtual ::OutputData< double > * getDetectorIntensity(  ) const  {
        if( bp::override func_getDetectorIntensity = this->get_override( "getDetectorIntensity" ) )
            return func_getDetectorIntensity(  );
        else{
            return this->GISASSimulation::getDetectorIntensity(  );
        }
    }
    
    ::OutputData< double > * default_getDetectorIntensity(  ) const  {
        return GISASSimulation::getDetectorIntensity( );
    }

    virtual int getNumberOfSimulationElements(  ) const  {
        if( bp::override func_getNumberOfSimulationElements = this->get_override( "getNumberOfSimulationElements" ) )
            return func_getNumberOfSimulationElements(  );
        else{
            return this->GISASSimulation::getNumberOfSimulationElements(  );
        }
    }
    
    int default_getNumberOfSimulationElements(  ) const  {
        return GISASSimulation::getNumberOfSimulationElements( );
    }

    virtual double getWavelength(  ) const  {
        if( bp::override func_getWavelength = this->get_override( "getWavelength" ) )
            return func_getWavelength(  );
        else{
            return this->GISASSimulation::getWavelength(  );
        }
    }
    
    double default_getWavelength(  ) const  {
        return GISASSimulation::getWavelength( );
    }

    virtual void prepareSimulation(  ) {
        if( bp::override func_prepareSimulation = this->get_override( "prepareSimulation" ) )
            func_prepareSimulation(  );
        else{
            this->GISASSimulation::prepareSimulation(  );
        }
    }
    
    void default_prepareSimulation(  ) {
        GISASSimulation::prepareSimulation( );
    }

    virtual bool areParametersChanged(  ) {
        if( bp::override func_areParametersChanged = this->get_override( "areParametersChanged" ) )
            return func_areParametersChanged(  );
        else{
            return this->IParameterized::areParametersChanged(  );
        }
    }
    
    bool default_areParametersChanged(  ) {
        return IParameterized::areParametersChanged( );
    }

    virtual void clearParameterPool(  ) {
        if( bp::override func_clearParameterPool = this->get_override( "clearParameterPool" ) )
            func_clearParameterPool(  );
        else{
            this->IParameterized::clearParameterPool(  );
        }
    }
    
    void default_clearParameterPool(  ) {
        IParameterized::clearParameterPool( );
    }

    virtual ::ParameterPool * createParameterTree(  ) const  {
        if( bp::override func_createParameterTree = this->get_override( "createParameterTree" ) )
            return func_createParameterTree(  );
        else{
            return this->IParameterized::createParameterTree(  );
        }
    }
    
    ::ParameterPool * default_createParameterTree(  ) const  {
        return IParameterized::createParameterTree( );
    }

    virtual void printParameters(  ) const  {
        if( bp::override func_printParameters = this->get_override( "printParameters" ) )
            func_printParameters(  );
        else{
            this->IParameterized::printParameters(  );
        }
    }
    
    void default_printParameters(  ) const  {
        IParameterized::printParameters( );
    }

    virtual void registerParameter( ::std::string const & name, double * parpointer, ::AttLimits const & limits=AttLimits::limitless( ) ) {
        namespace bpl = boost::python;
        if( bpl::override func_registerParameter = this->get_override( "registerParameter" ) ){
            bpl::object py_result = bpl::call<bpl::object>( func_registerParameter.ptr(), name, parpointer, limits );
        }
        else{
            IParameterized::registerParameter( name, parpointer, boost::ref(limits) );
        }
    }
    
    static void default_registerParameter( ::IParameterized & inst, ::std::string const & name, long unsigned int parpointer, ::AttLimits const & limits=AttLimits::limitless( ) ){
        if( dynamic_cast< GISASSimulation_wrapper * >( boost::addressof( inst ) ) ){
            inst.::IParameterized::registerParameter(name, reinterpret_cast< double * >( parpointer ), limits);
        }
        else{
            inst.registerParameter(name, reinterpret_cast< double * >( parpointer ), limits);
        }
    }

    virtual bool setParameterValue( ::std::string const & name, double value ) {
        if( bp::override func_setParameterValue = this->get_override( "setParameterValue" ) )
            return func_setParameterValue( name, value );
        else{
            return this->IParameterized::setParameterValue( name, value );
        }
    }
    
    bool default_setParameterValue( ::std::string const & name, double value ) {
        return IParameterized::setParameterValue( name, value );
    }

    virtual void setParametersAreChanged(  ) {
        if( bp::override func_setParametersAreChanged = this->get_override( "setParametersAreChanged" ) )
            func_setParametersAreChanged(  );
        else{
            this->IParameterized::setParametersAreChanged(  );
        }
    }
    
    void default_setParametersAreChanged(  ) {
        IParameterized::setParametersAreChanged( );
    }

    virtual void transferToCPP(  ) {
        
        if( !this->m_pyobj) {
            this->m_pyobj = boost::python::detail::wrapper_base_::get_owner(*this);
            Py_INCREF(this->m_pyobj);
        }
        
        if( bp::override func_transferToCPP = this->get_override( "transferToCPP" ) )
            func_transferToCPP(  );
        else{
            this->ICloneable::transferToCPP(  );
        }
    }
    
    void default_transferToCPP(  ) {
        
        if( !this->m_pyobj) {
            this->m_pyobj = boost::python::detail::wrapper_base_::get_owner(*this);
            Py_INCREF(this->m_pyobj);
        }
        
        ICloneable::transferToCPP( );
    }

    PyObject* m_pyobj;

};

void register_GISASSimulation_class(){

    { //::GISASSimulation
        typedef bp::class_< GISASSimulation_wrapper, bp::bases< Simulation >, std::auto_ptr< GISASSimulation_wrapper >, boost::noncopyable > GISASSimulation_exposer_t;
        GISASSimulation_exposer_t GISASSimulation_exposer = GISASSimulation_exposer_t( "GISASSimulation", "Main class to run the simulation.", bp::init< >() );
        bp::scope GISASSimulation_scope( GISASSimulation_exposer );
        { //::GISASSimulation::addMask
        
            typedef void ( ::GISASSimulation::*addMask_function_type)( ::Geometry::IShape2D const &,bool ) ;
            
            GISASSimulation_exposer.def( 
                "addMask"
                , addMask_function_type( &::GISASSimulation::addMask )
                , ( bp::arg("shape"), bp::arg("mask_value")=(bool)(true) )
                , "Adds mask of given shape to the stack of detector masks. The mask value 'true' means that the channel will be excluded from the simulation. The mask which is added last has priority. @param shape The shape of mask (Rectangle, Polygon, Line, Ellipse) @mask_value The value of mask \n\n:Parameters:\n  - 'shape' - The shape of mask (Rectangle, Polygon, Line, Ellipse)\n" );
        
        }
        { //::GISASSimulation::clone
        
            typedef ::GISASSimulation * ( ::GISASSimulation::*clone_function_type)(  ) const;
            typedef ::GISASSimulation * ( GISASSimulation_wrapper::*default_clone_function_type)(  ) const;
            
            GISASSimulation_exposer.def( 
                "clone"
                , clone_function_type(&::GISASSimulation::clone)
                , default_clone_function_type(&GISASSimulation_wrapper::default_clone)
                , bp::return_value_policy< bp::manage_new_object >() );
        
        }
        { //::GISASSimulation::getDetectorIntensity
        
            typedef ::OutputData< double > * ( ::GISASSimulation::*getDetectorIntensity_function_type)(  ) const;
            typedef ::OutputData< double > * ( GISASSimulation_wrapper::*default_getDetectorIntensity_function_type)(  ) const;
            
            GISASSimulation_exposer.def( 
                "getDetectorIntensity"
                , getDetectorIntensity_function_type(&::GISASSimulation::getDetectorIntensity)
                , default_getDetectorIntensity_function_type(&GISASSimulation_wrapper::default_getDetectorIntensity)
                , bp::return_value_policy< bp::manage_new_object >() );
        
        }
        { //::GISASSimulation::getInstrument
        
            typedef ::Instrument const & ( ::GISASSimulation::*getInstrument_function_type)(  ) const;
            
            GISASSimulation_exposer.def( 
                "getInstrument"
                , getInstrument_function_type( &::GISASSimulation::getInstrument )
                , bp::return_value_policy< bp::copy_const_reference >()
                , "Returns the instrument containing beam and detector information." );
        
        }
        { //::GISASSimulation::getIntensityData
        
            typedef ::Histogram2D * ( ::GISASSimulation::*getIntensityData_function_type)(  ) const;
            
            GISASSimulation_exposer.def( 
                "getIntensityData"
                , getIntensityData_function_type( &::GISASSimulation::getIntensityData )
                , bp::return_value_policy< bp::manage_new_object >()
                , "Returns clone of the detector intensity map with detector resolution applied in the form of 2D histogram. " );
        
        }
        { //::GISASSimulation::getNumberOfSimulationElements
        
            typedef int ( ::GISASSimulation::*getNumberOfSimulationElements_function_type)(  ) const;
            typedef int ( GISASSimulation_wrapper::*default_getNumberOfSimulationElements_function_type)(  ) const;
            
            GISASSimulation_exposer.def( 
                "getNumberOfSimulationElements"
                , getNumberOfSimulationElements_function_type(&::GISASSimulation::getNumberOfSimulationElements)
                , default_getNumberOfSimulationElements_function_type(&GISASSimulation_wrapper::default_getNumberOfSimulationElements) );
        
        }
        { //::GISASSimulation::getWavelength
        
            typedef double ( ::GISASSimulation::*getWavelength_function_type)(  ) const;
            typedef double ( GISASSimulation_wrapper::*default_getWavelength_function_type)(  ) const;
            
            GISASSimulation_exposer.def( 
                "getWavelength"
                , getWavelength_function_type(&::GISASSimulation::getWavelength)
                , default_getWavelength_function_type(&GISASSimulation_wrapper::default_getWavelength) );
        
        }
        { //::GISASSimulation::maskAll
        
            typedef void ( ::GISASSimulation::*maskAll_function_type)(  ) ;
            
            GISASSimulation_exposer.def( 
                "maskAll"
                , maskAll_function_type( &::GISASSimulation::maskAll )
                , "Put the mask for all detector channels (i.e. exclude whole detector from the analysis)." );
        
        }
        { //::GISASSimulation::normalize
        
            typedef void ( ::GISASSimulation::*normalize_function_type)(  ) ;
            
            GISASSimulation_exposer.def( 
                "normalize"
                , normalize_function_type( &::GISASSimulation::normalize )
                , "Normalize the detector counts." );
        
        }
        { //::GISASSimulation::prepareSimulation
        
            typedef void ( ::GISASSimulation::*prepareSimulation_function_type)(  ) ;
            typedef void ( GISASSimulation_wrapper::*default_prepareSimulation_function_type)(  ) ;
            
            GISASSimulation_exposer.def( 
                "prepareSimulation"
                , prepareSimulation_function_type(&::GISASSimulation::prepareSimulation)
                , default_prepareSimulation_function_type(&GISASSimulation_wrapper::default_prepareSimulation) );
        
        }
        { //::GISASSimulation::removeDetectorResolutionFunction
        
            typedef void ( ::GISASSimulation::*removeDetectorResolutionFunction_function_type)(  ) ;
            
            GISASSimulation_exposer.def( 
                "removeDetectorResolutionFunction"
                , removeDetectorResolutionFunction_function_type( &::GISASSimulation::removeDetectorResolutionFunction )
                , "Removes detector resolution function." );
        
        }
        { //::GISASSimulation::removeMasks
        
            typedef void ( ::GISASSimulation::*removeMasks_function_type)(  ) ;
            
            GISASSimulation_exposer.def( 
                "removeMasks"
                , removeMasks_function_type( &::GISASSimulation::removeMasks )
                , "removes all masks from the detector." );
        
        }
        { //::GISASSimulation::setAnalyzerProperties
        
            typedef void ( ::GISASSimulation::*setAnalyzerProperties_function_type)( ::kvector_t const &,double,double ) ;
            
            GISASSimulation_exposer.def( 
                "setAnalyzerProperties"
                , setAnalyzerProperties_function_type( &::GISASSimulation::setAnalyzerProperties )
                , ( bp::arg("direction"), bp::arg("efficiency"), bp::arg("total_transmission")=1.0e+0 )
                , "Sets the polarization analyzer characteristics of the detector." );
        
        }
        { //::GISASSimulation::setBeamIntensity
        
            typedef void ( ::GISASSimulation::*setBeamIntensity_function_type)( double ) ;
            
            GISASSimulation_exposer.def( 
                "setBeamIntensity"
                , setBeamIntensity_function_type( &::GISASSimulation::setBeamIntensity )
                , ( bp::arg("intensity") )
                , "Sets beam intensity from here (forwarded to Instrument)." );
        
        }
        { //::GISASSimulation::setBeamParameters
        
            typedef void ( ::GISASSimulation::*setBeamParameters_function_type)( double,double,double ) ;
            
            GISASSimulation_exposer.def( 
                "setBeamParameters"
                , setBeamParameters_function_type( &::GISASSimulation::setBeamParameters )
                , ( bp::arg("wavelength"), bp::arg("alpha_i"), bp::arg("phi_i") )
                , "Sets beam parameters from here (forwarded to Instrument)." );
        
        }
        { //::GISASSimulation::setBeamPolarization
        
            typedef void ( ::GISASSimulation::*setBeamPolarization_function_type)( ::kvector_t const & ) ;
            
            GISASSimulation_exposer.def( 
                "setBeamPolarization"
                , setBeamPolarization_function_type( &::GISASSimulation::setBeamPolarization )
                , ( bp::arg("bloch_vector") )
                , "Sets the beam polarization according to the given Bloch vector." );
        
        }
        { //::GISASSimulation::setDetector
        
            typedef void ( ::GISASSimulation::*setDetector_function_type)( ::IDetector2D const & ) ;
            
            GISASSimulation_exposer.def( 
                "setDetector"
                , setDetector_function_type( &::GISASSimulation::setDetector )
                , ( bp::arg("detector") )
                , "Sets the detector (axes can be overwritten later)." );
        
        }
        { //::GISASSimulation::setDetectorParameters
        
            typedef void ( ::GISASSimulation::*setDetectorParameters_function_type)( ::OutputData< double > const & ) ;
            
            GISASSimulation_exposer.def( 
                "setDetectorParameters"
                , setDetectorParameters_function_type( &::GISASSimulation::setDetectorParameters )
                , ( bp::arg("output_data") )
                , "Sets detector parameters using axes of output data." );
        
        }
        { //::GISASSimulation::setDetectorParameters
        
            typedef void ( ::GISASSimulation::*setDetectorParameters_function_type)( ::IHistogram const & ) ;
            
            GISASSimulation_exposer.def( 
                "setDetectorParameters"
                , setDetectorParameters_function_type( &::GISASSimulation::setDetectorParameters )
                , ( bp::arg("hisotgram") )
                , "Sets detector parameters using axes of output data." );
        
        }
        { //::GISASSimulation::setDetectorParameters
        
            typedef void ( ::GISASSimulation::*setDetectorParameters_function_type)( ::std::size_t,double,double,::std::size_t,double,double,bool ) ;
            
            GISASSimulation_exposer.def( 
                "setDetectorParameters"
                , setDetectorParameters_function_type( &::GISASSimulation::setDetectorParameters )
                , ( bp::arg("n_phi"), bp::arg("phi_f_min"), bp::arg("phi_f_max"), bp::arg("n_alpha"), bp::arg("alpha_f_min"), bp::arg("alpha_f_max"), bp::arg("isgisaxs_style")=(bool)(false) )
                , "Sets detector parameters using angle ranges." );
        
        }
        { //::GISASSimulation::setDetectorResolutionFunction
        
            typedef void ( ::GISASSimulation::*setDetectorResolutionFunction_function_type)( ::IResolutionFunction2D const & ) ;
            
            GISASSimulation_exposer.def( 
                "setDetectorResolutionFunction"
                , setDetectorResolutionFunction_function_type( &::GISASSimulation::setDetectorResolutionFunction )
                , ( bp::arg("resolution_function") )
                , "Define resolution function for detector." );
        
        }
        { //::GISASSimulation::setInstrument
        
            typedef void ( ::GISASSimulation::*setInstrument_function_type)( ::Instrument const & ) ;
            
            GISASSimulation_exposer.def( 
                "setInstrument"
                , setInstrument_function_type( &::GISASSimulation::setInstrument )
                , ( bp::arg("instrument") )
                , "Sets the instrument containing beam and detector information." );
        
        }
        { //::IParameterized::areParametersChanged
        
            typedef bool ( ::IParameterized::*areParametersChanged_function_type)(  ) ;
            typedef bool ( GISASSimulation_wrapper::*default_areParametersChanged_function_type)(  ) ;
            
            GISASSimulation_exposer.def( 
                "areParametersChanged"
                , areParametersChanged_function_type(&::IParameterized::areParametersChanged)
                , default_areParametersChanged_function_type(&GISASSimulation_wrapper::default_areParametersChanged) );
        
        }
        { //::IParameterized::clearParameterPool
        
            typedef void ( ::IParameterized::*clearParameterPool_function_type)(  ) ;
            typedef void ( GISASSimulation_wrapper::*default_clearParameterPool_function_type)(  ) ;
            
            GISASSimulation_exposer.def( 
                "clearParameterPool"
                , clearParameterPool_function_type(&::IParameterized::clearParameterPool)
                , default_clearParameterPool_function_type(&GISASSimulation_wrapper::default_clearParameterPool) );
        
        }
        { //::IParameterized::createParameterTree
        
            typedef ::ParameterPool * ( ::IParameterized::*createParameterTree_function_type)(  ) const;
            typedef ::ParameterPool * ( GISASSimulation_wrapper::*default_createParameterTree_function_type)(  ) const;
            
            GISASSimulation_exposer.def( 
                "createParameterTree"
                , createParameterTree_function_type(&::IParameterized::createParameterTree)
                , default_createParameterTree_function_type(&GISASSimulation_wrapper::default_createParameterTree)
                , bp::return_value_policy< bp::manage_new_object >() );
        
        }
        { //::IParameterized::printParameters
        
            typedef void ( ::IParameterized::*printParameters_function_type)(  ) const;
            typedef void ( GISASSimulation_wrapper::*default_printParameters_function_type)(  ) const;
            
            GISASSimulation_exposer.def( 
                "printParameters"
                , printParameters_function_type(&::IParameterized::printParameters)
                , default_printParameters_function_type(&GISASSimulation_wrapper::default_printParameters) );
        
        }
        { //::IParameterized::registerParameter
        
            typedef void ( *default_registerParameter_function_type )( ::IParameterized &,::std::string const &,long unsigned int,::AttLimits const & );
            
            GISASSimulation_exposer.def( 
                "registerParameter"
                , default_registerParameter_function_type( &GISASSimulation_wrapper::default_registerParameter )
                , ( bp::arg("inst"), bp::arg("name"), bp::arg("parpointer"), bp::arg("limits")=AttLimits::limitless( ) )
                , "main method to register data address in the pool." );
        
        }
        { //::IParameterized::setParameterValue
        
            typedef bool ( ::IParameterized::*setParameterValue_function_type)( ::std::string const &,double ) ;
            typedef bool ( GISASSimulation_wrapper::*default_setParameterValue_function_type)( ::std::string const &,double ) ;
            
            GISASSimulation_exposer.def( 
                "setParameterValue"
                , setParameterValue_function_type(&::IParameterized::setParameterValue)
                , default_setParameterValue_function_type(&GISASSimulation_wrapper::default_setParameterValue)
                , ( bp::arg("name"), bp::arg("value") ) );
        
        }
        { //::IParameterized::setParametersAreChanged
        
            typedef void ( ::IParameterized::*setParametersAreChanged_function_type)(  ) ;
            typedef void ( GISASSimulation_wrapper::*default_setParametersAreChanged_function_type)(  ) ;
            
            GISASSimulation_exposer.def( 
                "setParametersAreChanged"
                , setParametersAreChanged_function_type(&::IParameterized::setParametersAreChanged)
                , default_setParametersAreChanged_function_type(&GISASSimulation_wrapper::default_setParametersAreChanged) );
        
        }
        { //::ICloneable::transferToCPP
        
            typedef void ( ::ICloneable::*transferToCPP_function_type)(  ) ;
            typedef void ( GISASSimulation_wrapper::*default_transferToCPP_function_type)(  ) ;
            
            GISASSimulation_exposer.def( 
                "transferToCPP"
                , transferToCPP_function_type(&::ICloneable::transferToCPP)
                , default_transferToCPP_function_type(&GISASSimulation_wrapper::default_transferToCPP) );
        
        }
    }

}
