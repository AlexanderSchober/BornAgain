// This file has been generated by Py++.

// ************************************************************************** //
//
//  BornAgain: simulate and fit scattering at grazing incidence
//
//! @file      Automatically generated boost::python code for BornAgain Python bindings
//! @brief     Automatically generated boost::python code for BornAgain Python bindings
//!
//! @homepage  http://bornagainproject.org
//! @license   GNU General Public License v3 or higher (see COPYING)
//! @copyright Forschungszentrum Juelich GmbH 2015
//! @authors   Scientific Computing Group at MLZ Garching
//! @authors   C. Durniak, M. Ganeva, G. Pospelov, W. Van Herck, J. Wuttke
//
// ************************************************************************** //

#include "Macros.h"
GCC_DIAG_OFF(unused-parameter)
GCC_DIAG_OFF(missing-field-initializers)
#include "boost/python.hpp"
GCC_DIAG_ON(unused-parameter)
GCC_DIAG_ON(missing-field-initializers)
#include "PythonCoreList.h"
#include "Instrument.pypp.h"

namespace bp = boost::python;

void register_Instrument_class(){

    { //::Instrument
        typedef bp::class_< Instrument, bp::bases< IParameterized > > Instrument_exposer_t;
        Instrument_exposer_t Instrument_exposer = Instrument_exposer_t( "Instrument", "Assembles beam, detector and their relative positions wrt the sample.", bp::no_init );
        bp::scope Instrument_scope( Instrument_exposer );
        Instrument_exposer.def( bp::init< >() );
        Instrument_exposer.def( bp::init< Instrument const & >(( bp::arg("other") )) );
        { //::Instrument::getBeam
        
            typedef ::Beam ( ::Instrument::*getBeam_function_type)(  ) const;
            
            Instrument_exposer.def( 
                "getBeam"
                , getBeam_function_type( &::Instrument::getBeam ) );
        
        }
        { //::Instrument::getBeamIntensity
        
            typedef double ( ::Instrument::*getBeamIntensity_function_type)(  ) const;
            
            Instrument_exposer.def( 
                "getBeamIntensity"
                , getBeamIntensity_function_type( &::Instrument::getBeamIntensity ) );
        
        }
        { //::Instrument::getDetector
        
            typedef ::IDetector2D const * ( ::Instrument::*getDetector_function_type)(  ) const;
            
            Instrument_exposer.def( 
                "getDetector"
                , getDetector_function_type( &::Instrument::getDetector )
                , bp::return_value_policy< bp::reference_existing_object >() );
        
        }
        { //::Instrument::getDetector
        
            typedef ::IDetector2D * ( ::Instrument::*getDetector_function_type)(  ) ;
            
            Instrument_exposer.def( 
                "getDetector"
                , getDetector_function_type( &::Instrument::getDetector )
                , bp::return_value_policy< bp::reference_existing_object >() );
        
        }
        { //::Instrument::getDetectorAxis
        
            typedef ::IAxis const & ( ::Instrument::*getDetectorAxis_function_type)( ::std::size_t ) const;
            
            Instrument_exposer.def( 
                "getDetectorAxis"
                , getDetectorAxis_function_type( &::Instrument::getDetectorAxis )
                , ( bp::arg("index") )
                , bp::return_value_policy< bp::copy_const_reference >() );
        
        }
        { //::Instrument::getDetectorDimension
        
            typedef ::std::size_t ( ::Instrument::*getDetectorDimension_function_type)(  ) const;
            
            Instrument_exposer.def( 
                "getDetectorDimension"
                , getDetectorDimension_function_type( &::Instrument::getDetectorDimension ) );
        
        }
        { //::Instrument::getDetectorIntensity
        
            typedef ::OutputData< double > * ( ::Instrument::*getDetectorIntensity_function_type)( ::OutputData< double > const &,::IDetector2D::EAxesUnits ) const;
            
            Instrument_exposer.def( 
                "getDetectorIntensity"
                , getDetectorIntensity_function_type( &::Instrument::getDetectorIntensity )
                , ( bp::arg("data"), bp::arg("units_type")=::IDetector2D::DEFAULT )
                , bp::return_value_policy< bp::reference_existing_object >()
                , "Returns clone of the intensity map with detector resolution applied, axes of map will be in requested units " );
        
        }
        { //::Instrument::initDetector
        
            typedef void ( ::Instrument::*initDetector_function_type)(  ) ;
            
            Instrument_exposer.def( 
                "initDetector"
                , initDetector_function_type( &::Instrument::initDetector )
                , "init detector with beam settings." );
        
        }
        { //::Instrument::matchDetectorAxes
        
            typedef void ( ::Instrument::*matchDetectorAxes_function_type)( ::OutputData< double > const & ) ;
            
            Instrument_exposer.def( 
                "matchDetectorAxes"
                , matchDetectorAxes_function_type( &::Instrument::matchDetectorAxes )
                , ( bp::arg("output_data") )
                , "Sets detector parameters using axes of output data." );
        
        }
        { //::Instrument::operator=
        
            typedef ::Instrument & ( ::Instrument::*assign_function_type)( ::Instrument const & ) ;
            
            Instrument_exposer.def( 
                "assign"
                , assign_function_type( &::Instrument::operator= )
                , ( bp::arg("other") )
                , bp::return_self< >() );
        
        }
        { //::Instrument::setAnalyzerProperties
        
            typedef void ( ::Instrument::*setAnalyzerProperties_function_type)( ::kvector_t const &,double,double ) ;
            
            Instrument_exposer.def( 
                "setAnalyzerProperties"
                , setAnalyzerProperties_function_type( &::Instrument::setAnalyzerProperties )
                , ( bp::arg("direction"), bp::arg("efficiency"), bp::arg("total_transmission")=1.0e+0 ) );
        
        }
        { //::Instrument::setBeam
        
            typedef void ( ::Instrument::*setBeam_function_type)( ::Beam const & ) ;
            
            Instrument_exposer.def( 
                "setBeam"
                , setBeam_function_type( &::Instrument::setBeam )
                , ( bp::arg("beam") )
                , "Sets the beam data." );
        
        }
        { //::Instrument::setBeamIntensity
        
            typedef void ( ::Instrument::*setBeamIntensity_function_type)( double ) ;
            
            Instrument_exposer.def( 
                "setBeamIntensity"
                , setBeamIntensity_function_type( &::Instrument::setBeamIntensity )
                , ( bp::arg("intensity") ) );
        
        }
        { //::Instrument::setBeamParameters
        
            typedef void ( ::Instrument::*setBeamParameters_function_type)( double,double,double ) ;
            
            Instrument_exposer.def( 
                "setBeamParameters"
                , setBeamParameters_function_type( &::Instrument::setBeamParameters )
                , ( bp::arg("wavelength"), bp::arg("alpha_i"), bp::arg("phi_i") )
                , "Sets the beam wavelength and incoming angles." );
        
        }
        { //::Instrument::setBeamPolarization
        
            typedef void ( ::Instrument::*setBeamPolarization_function_type)( ::kvector_t const & ) ;
            
            Instrument_exposer.def( 
                "setBeamPolarization"
                , setBeamPolarization_function_type( &::Instrument::setBeamPolarization )
                , ( bp::arg("bloch_vector") ) );
        
        }
        { //::Instrument::setDetector
        
            typedef void ( ::Instrument::*setDetector_function_type)( ::IDetector2D const & ) ;
            
            Instrument_exposer.def( 
                "setDetector"
                , setDetector_function_type( &::Instrument::setDetector )
                , ( bp::arg("detector") )
                , "Sets the detector (axes can be overwritten later)." );
        
        }
        { //::Instrument::setDetectorAxes
        
            typedef void ( ::Instrument::*setDetectorAxes_function_type)( ::IAxis const &,::IAxis const & ) ;
            
            Instrument_exposer.def( 
                "setDetectorAxes"
                , setDetectorAxes_function_type( &::Instrument::setDetectorAxes )
                , ( bp::arg("axis0"), bp::arg("axis1") )
                , "Sets detector parameters using axes." );
        
        }
        { //::Instrument::setDetectorParameters
        
            typedef void ( ::Instrument::*setDetectorParameters_function_type)( ::std::size_t,double,double,::std::size_t,double,double ) ;
            
            Instrument_exposer.def( 
                "setDetectorParameters"
                , setDetectorParameters_function_type( &::Instrument::setDetectorParameters )
                , ( bp::arg("n_x"), bp::arg("x_min"), bp::arg("x_max"), bp::arg("n_y"), bp::arg("y_min"), bp::arg("y_max") )
                , "Sets detector parameters using angle ranges." );
        
        }
        { //::Instrument::setDetectorResolutionFunction
        
            typedef void ( ::Instrument::*setDetectorResolutionFunction_function_type)( ::IResolutionFunction2D const & ) ;
            
            Instrument_exposer.def( 
                "setDetectorResolutionFunction"
                , setDetectorResolutionFunction_function_type( &::Instrument::setDetectorResolutionFunction )
                , ( bp::arg("p_resolution_function") )
                , "Sets detector resolution function." );
        
        }
    }

}
