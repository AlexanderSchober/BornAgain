\newpage
\chapter{Fitting}

%     Minuit Library:
%         Migrad Algorithm ("Minuit", "Migrad"),
%         Simplex Algorithm ("Minuit", "Simplex")
%         Minimize Algorithm ("Minuit", "Minimize")
%         Scan Algorithm ("Minuit", "Scan")
%         Seek Algorithm ("Minuit", "Seek")
%     Fumili Library:
%         Fumili Algorithm
%     Minuit2 Library:
%         Migrad Algorithm ("Minuit2", "Migrad")
%         Simplex Algorithm ("Minuit2", "Simplex")
%         Minimize Algorithm ("Minuit2", "Minimize")
%         Scan Algorithm ("Minuit2", "Scan")
%         Fumili2 Algorithm ("Minuit2", "Fumili2")
%     GSL Library: (Only available if GSL and MathMore are avaiable too)
%         Fletcher-Reeves Conjugate Gradient Algorithm ("GSLMultiMin", "conjugatefr")
%         Polak-Ribiere Conjugate Gradient Algorithm ("GSLMultiMin", "conjugatepr")
%         BFGS Conjugate Gradient Algorithm ("GSLMultiMin", "bfgs2")
%         Levenberg-Marquardt Algorithm ("GSLMultiFit", "")
%         Simulated Annealing Algorithm ("GSLSimAn", "")

In addition to the simulation of grazing incidence
x-ray and neutron scattering by
multilayered samples, BornAgain also offers the option to
fit a selection of simulated sample parameters to experimental data.  This aspect
of the software is discussed in this chapter.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Short description of fitting theory}

These features of BornAgain deal with estimating the optimum parameters
in the simulation by minimizing the difference ($\chi^2$) between theory and experimental data.\\

\textbf{From Minuit user's guide}: Minuit is usually used to find the ``best'' values of a set of
parameters, where ``best'' is defined as those values which minimize a
given function, FCN. The width of the function minimum in some
neighbourhood of the minimum, gives information about the uncertainty
in the best parameter values. An important feature of Minuit is that
it offers several tools to analyze the parameter errors.



\noindent \smallpencil \colorbox{Lightgray}{\parbox{\dimexpr\linewidth-8\fboxsep}
{\underline{Theory}: Users wanting to find out more about minimization (also called
maximization or optimization methods) are referred to \ldots.}}\\

%The conjugate gradient and BFGS methods are described in detail in the following book,
%    R. Fletcher, Practical Methods of Optimization (Second Edition) Wiley (1987), ISBN 0471915475. 
%A brief description of multidimensional minimization algorithms and more recent references can be found in,
%    C.W. Ueberhuber, Numerical Computation (Volume 2), Chapter 14, Section 4.4 Minimization Methods, p. 325–335, Springer (1997), ISBN 3-540-62057-5
%The simplex algorithm is described in the following paper,
%    J.A. Nelder and R. Mead, A simplex method for function minimization, Computer Journal vol. 7 (1965), 308–313. 
% W. T. Eadie, D. Drijard, F. James, M. Roos, and B. Sadouletm
% Statistical methods in experimental physics, North-Holland 1971

Local minimum, multiple minima

%\url{http://seal.web.cern.ch/seal/MathLibs/Minuit2/html/}

%\url{http://seal.web.cern.ch/seal/documents/minuit/mntutorial.pdf}

%\url{http://root.cern.ch/root/html/MATH_MINUIT2_Index.html}

A detailed tutorial of Minuit software can be downloaded at the
following address \url{http://seal.web.cern.ch/seal/documents/minuit/mnusersguide.pdf}.
%\cite{MinuitRoot}.

Local or global minimization
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Implementation in BornAgain}
BornAgain fitting features include...\\
Different geometries, number of fit parameters, variety of minimizers\\
and minimization strategies.\\

Minimizer belongs to MinimizerFactory (interacts with Root)

Variable parameters: customize lists, inputs required, default values

Methods: implemented list, possibility to add your own.

Set/create minimizer : name + algorithm + option (part of Minimizer
factory). The minimizers can be chosen from the following list:

FitSuite: m\_minimizer, m\_is\_last\_iteration

\textbf{Questions}
\begin{itemize}
\item Is it possible to fit on the particle kind (cylinder or prism or
\ldots)?
\item Fit using several experimental runs?
\item Number of degrees of freedom?
\item Weighted fits?
\item Errorbars, epsilon for standard error
\item Normalisation of the data (in order to be compared)
\item Constraints between parameters
\item Quick fit option
\item Possible exponential decrease of the form factor
\item fit of 1D plots?
\end{itemize}
%To run tests: python TestFit.py\\
%List of tests\\
%TestFit01 - Two parameter fit using variety of minimizers. Geometry: cylinders in the air.\\
%TestFit02 - Fitting using sample builder\\


Class TestFittingModule1: 
\begin{itemize}
\item mp\_real\_data (experimental data), 
\item mp\_simulated\_data,
\item mp\_simulation, 
\item mp\_sample, 
\item mp\_fitsuite: \texttt{addSimulationAndRealdData}: link a given set of experimental data with a
  particular set of simulated data in order to proceed to a fit. It is
  therefore possible to generate a batch of different numerical
  samples to test different configurations in order to obtain the best
  fit by playing with the number of layers or the shape of particles
  (different form factors). What about \texttt{chi2\_module} by default?
\end{itemize} 

\texttt{attachObserver} uses
\texttt{FitSuiteObserverFactory::CreatePrintObserver()} or
\texttt{FitSuiteObserverFactory::CreateDrawObserver()} or
\texttt{FitSuiteObserverFactory::CreateTreeObserver()}.


%runFit()

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{General procedure to fit / for fitting}

Format of input (experimental data) - requirements (structure,
normalisation, values...)
Experimental data can be entered by importing it from ASCII files created by other applications.
%Therefore the number of layers cannot be used as a fitting parameter

A fit is run for a fixed value of \textbf{the number of layers
  constituting the sample}, the \textbf{input beam wavelength}.

Input = matrix of intensity as function of ?

Generation of the numerical model (cf other examples or detailed
description or only script given and description of main steps)

\textbf{Structure of fitting module in BornAgain.}


\textbf{Structure of Fit folder (sources *.cpp):}
\begin{itemize}
\item FitObject.cpp
\item FitSuiteObjects.cpp		
\item MinimizerFactory.cpp
\item ROOTMinimizer.cpp
\item FitParameter.cpp		
\item FitSuiteParameters.cpp		
\item MinimizerScan.cpp		
\item ROOTMinimizerHelper.cpp
\item FitParameterLinked.cpp		
\item FitSuitePrintObserver.cpp	
\item MinimizerTest.cpp
\item FitSuite.cpp			
\item FitSuiteStrategies.cpp		
\item ROOTGSLNLSMinimizer.cpp
\item FitSuiteFunctions.cpp		
\item IFitSuiteStrategy.cpp
\item ROOTGSLSimAnMinimizer.cpp
\end{itemize}

\textbf{Structure of Fit folder (headers *.h):}
\begin{itemize}
\item AttFitting.h		
\item FitSuite.h		
\item FitSuiteStrategies.h	
\item MinimizerTest.h		
\item ROOTMinimizerHelper.h
\item AttLimits.h		
\item FitSuiteFunctions.h	
\item IFitSuiteStrategy.h	
\item ROOTGSLNLSMinimizer.h
\item FitObject.h		
\item FitSuiteObjects.h	
\item IMinimizer.h		
\item ROOTGSLSimAnMinimizer.h
\item FitParameter.h		
\item FitSuiteParameters.h	
\item MinimizerFactory.h	
\item ROOTMinimizer.h
\item FitParameterLinked.h	
\item FitSuitePrintObserver.h	
\item MinimizerScan.h		
\item ROOTMinimizerFunction.h
\end{itemize}

\myparagraph{\underline{Choice of parameters to be fitted}}
In principle, every parameter used in the construction of the sample
can be used as a fit parameter. For example

\begin{table}[h]
\centering
\begin{tabular}{|@{}l||l@{}|}
\hline
\textbf{Particles} &  dimensions: height, radius, length, width, \\
                             &  half side length, thickness, \textbf{index of refraction} 
                             height\_aspect\_ratio, \textbf{orientation?} \\
& (depending on the shape) \\
& inteference (density, proportion, width, distance,\\
& probability,
dispersion radius) \\
\hline
\textbf{Lattice} & \\
\hline
\textbf{Layers} & roughness, thickness, \textbf{index of refraction} \\
\hline
\textbf{Beam} & intensity \\
\hline
\textbf{Detector} & \\
\hline
\end{tabular}
\label{table:fitting_parameters}
\caption{List of parameters that can be defined as fitting parameters.}
\end{table}

The heights of different particles can be associated to two different
fitting parameters and optimized / minimized separately.


m\_cylinder\_ratio, m\_cylinder\_height
m\_prism3\_half\_side, m\_prism3\_height
                          
  *Normalizer/scale
  *Normalizer/shift

  *SampleBuilder/particle\_probability1
  *SampleBuilder/particle\_radius1
  *SampleBuilder/dispersion\_radius1
  *SampleBuilder/height\_aspect\_ratio1

  *SampleBuilder/interf\_distance
  *SampleBuilder/interf\_width

 *SampleBuilder/height\_aspect\_ratio
 
   */lattice\_length\_a 
   */lattice\_length\_c   
   */nanoparticle\_radius",     
   */sigma\_nanoparticle\_radius
   */meso\_height       
   */meso\_radius  
   */sigma\_meso\_height
   */sigma\_meso\_radius
   */sigma\_lattice\_length\_a
   */surface\_filling\_ratio
   */roughness

 
In BornAgain, the parameters used for the fit are specified using the
function \texttt{addFitParameter} with the following syntax:

\begin{lstlisting}[language=C++, style=eclipse,numbers=none]
m\_fitSuite->addFitParameter("*height", 4.*Units::nanometer,
0.04*Units::nanometer, AttLimits::lowerLimited(0.01) );

m\_fitSuite->addFitParameter("*radius", 6.*Units::nanometer,
0.06*Units::nanometer, AttLimits::lowerLimited(0.01) );

m\_fitSuite->addFitParameter("*SampleBuilder/m\_cylinder\_height",4*Units::nanometer, 0.01*Units::nanometer,AttLimits::lowerLimited(0.01) );

m\_fitSuite->addFitParameter("*SampleBuilder/m\_cylinder\_radius",
  6*Units::nanometer, 0.01*Units::nanometer, AttLimits::lowerLimited(0.01) );

m\_fitSuite->addFitParameter("*SampleBuilder/m\_prism3\_half\_side", 4*Units::nanometer, 0.01*Units::nanometer,  AttLimits::lowerLimited(0.01) );
\end{lstlisting}

There are two possible syntaxes:
\begin{itemize}
\item First option: \\ \texttt{m\_fitSuite->addFitParameter(name, value, step, attlim, error);},
where \texttt{value}, \texttt{step} and \texttt{error} are double values corresponding to the ... respectively.
\item Second option: \\
\texttt{m\_fitSuite->addFitParameter(name, value, attlim, error);}
\end{itemize}

\texttt{attlim} is , \texttt{name} is ...
By default the input value of \texttt{error} is 0.
 

\texttt{AttLimits} can be
\begin{itemize}
\item fixed(), 
\item lowerLimited(double value), 
\item limited(double min value, double max value).
\end{itemize}
The unit of \texttt{AttLimits} is  identical to the one used to characterize the
parameter.

Number of iterations
Interrupt fit
Procedure: initially choose a small number of fitting parameters

\textbf{ Software Scatter :The program allows to automatically fit large number of data files such as files from timeresolved
studies. A requirement is that subsequent scattering curves do not differ too much, so
that the fitted values of the first curve can be used as starting parameters for a fit to the next
curve. Before starting a fit series, choose the first data file and perform a fit so that the
parameter values are set to an optimal start value. The first/last point, qmin/max and Imin for
the fit will apply to all data sets.}

Background noise, intensity threshold.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Fitting methods implemented}

\textbf{Is there any default method implemented?}
Different minimizers from Root library can be used in BornAgain. They are listed in
Table~\ref{table:fit_minimizers}. Users can also add their own by
implementing their definition in the \texttt{Catalogue} contained in
program \texttt{MinimizerFactory}.
Minuit user's manual describes which minimizer to use in order to best
fit our data\ldots  \cite{MinuitRoot}.

\begin{table}[h]
\centering
\begin{tabular}{@{}ll@{}}
\hline
\hline
\textbf{Minimizer name - Library} & \textbf{Algorithm} \\
\hline
%Test & \\
%Scan & \\%[-3pt] 
Minuit & Migrad, Simplex, Combined, Scan\\
Minuit2 & Migrad, Simplex, Combined, Scan, Fumili \\
Fumili & \\
GSLMultiMin & ConjugateFR, ConjugatePR, BFGS, BFGS2, SteepestDescent \\
GSLMultiFit & \\
GSLSimAn & \\ %Simulatded annealing algorithm
Genetic &  \\ %TMVA Toolkit for Multivariate Data Analysis with ROOT 
\hline
\hline
\end{tabular}
\label{table:fit_minimizers}
\caption{List of fitting minimizers implemented in BornAgain.}
\end{table}




Minuit2, originally developed in the SEAL project, is now distributed
within ROOT. The classes have been moved inside the namespace
ROOT::Minuit2. 

Minuit is conceived as a tool to find the minumum value of a
multi-parameter function and analyze the shape of the function around
the minimum. The principal application is foreseen for statistical
analysis, working on chisquare or log-likelihood functions, to compute
the best-fit parameter values and uncertainties, including
correlations between the parameters. It is especially suite to handle
difficult problems, including those which may requier guidance in
order to find the correct solution.

Minuit2, optional package in the ROOT framework, is a numerical minimization computer program
originally written in C++ programming language. The program searches for minima in a user-defined function with
respect to one or more parameters using several different methods as
specified by the user. 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Outputs}
log file, how to interpret the data, how to save the estimated parameters.
Customize using \texttt{Observer}.
See FitGISAXS, IsGISAXS, Fish.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Examples}
in C++ or Python?
TestPyFit: testfit01.py, testfit02.py
FitSuite

Observer

Screenshot after running the program
Graph?
Simulation
Real data


Difference between TestFit and TestPyFit

Different steps to follow - order of execution

%%%%%%%%%%%%%%%%%%%%%
\myparagraph{\underline{First step:} Initializing the simulation}

 definition of the detector's
  parameters \texttt{setDetectorParameters} and the beam's parameters
  \texttt{setBeamParameters}

%%%%%%%%%%%%%%%%%%%%%
\myparagraph{\underline{Generating the sample}}

Layers, particles, 

%%%%%%%%%%%%%%%%%%%%%
\myparagraph{\underline{Choice of parameters to be fitted}}

choice of parameters
  to be used for minimization \texttt{addFitParameter}. 

%%%%%%%%%%%%%%%%%%%%%
\myparagraph{\underline{Running the simulation / the fit}}

Normalisation ?

Output = two-dimensional matrix.

How to run the fit: using the function \texttt{fit}



\begin{lstlisting}[caption={Python script of fitting example},
  label=script_exfit1,captionpos=b,escapeinside={@}{@} ,language=python,style=eclipse, numbers= none,frame = leftline ,
      framerule = 2mm ,
      rulecolor = \color{lightgrey},
      breaklines = true]
# In this test we are using simple geometry: cylinders without interference in
# air layer with two parameters (radius and height of cylinders), describing
# the sample. Our "real" data is 2D intensity map obtained from the simulation of
# the same geometry with fixed values height = 5nm and radius = 5nm.
# Then we run our minimization consequently using different minimization engines,
# with height=4nm, radius=6nm as starting fit parameter values.
import sys
import os
import numpy
import time

sys.path.append(os.path.abspath(
                os.path.join(os.path.split(__file__)[0],
                '..', '..', '..', 'lib')))

from libBornAgainCore import *
from libBornAgainFit import *

# sample parameters we are going to find
cylinder_height = 5*nanometer
cylinder_radius = 5*nanometer

# minimizer name and type of minimization algorithm
Minimizers = [ 
    ("Minuit2","Migrad"), 
    ("Minuit2","Fumili"), 
    ("GSLMultiMin","BFGS"),
    ("GSLMultiMin","SteepestDescent"),
    ("GSLMultiFit",""),
#    ("GSLSimAn","")
]

# -----------------------------------------------------------------------------
# run several minimization rounds using different minimizers
# -----------------------------------------------------------------------------
def runTest():
    #print "**********************************************************************"
    #print "*  Starting  TestFit01                                               *"
    #print "**********************************************************************"
    nTest=0
    status = "OK"
    for m in Minimizers:
        minimizer_name = m[0]
        minimizer_algorithm = m[1]
        print "Minimizer {0:-2d}   {1:}({2:})".format(nTest, minimizer_name, minimizer_algorithm)
        result_ok = run_fitting(minimizer_name, minimizer_algorithm)
        nTest+=1
        if not result_ok: status = "FAILED"

    return "TestFit01", "Two parameters fit using variety of minimizers.", status

# -----------------------------------------------------------------------------
# run fitting specified minimizer
# -----------------------------------------------------------------------------
def run_fitting(minimizer_name, minimizer_algorithm):
    sample = buildSample()
    simulation = createSimulation()
    simulation.setSample(sample)

    # creating real data, which is simply results of our simulation with default values
    simulation.runSimulation()
    real_data = simulation.getOutputDataClone()

    # setting fit suite
    fitSuite = FitSuite()
    fitSuite.setMinimizer( MinimizerFactory.createMinimizer(minimizer_name, minimizer_algorithm) )
    fitSuite.addFitParameter("*height", 4.*nanometer, 0.04*nanometer, AttLimits.lowerLimited(0.01) )
    fitSuite.addFitParameter("*radius", 6.*nanometer, 0.06*nanometer, AttLimits.lowerLimited(0.01) )
    fitSuite.addSimulationAndRealData(simulation, real_data)

    # run fit
    start_time = time.time()
    fitSuite.runFit()
    real_time = time.time() - start_time

    height_found = fitSuite.getMinimizer().getValueOfVariableAtMinimum(0)
    height_diff = abs(height_found - cylinder_height)/cylinder_height
    radius_found = fitSuite.getMinimizer().getValueOfVariableAtMinimum(1)
    radius_diff = abs(radius_found - cylinder_radius)/cylinder_radius

    print "            RealTime : {0:.3f} sec".format(real_time)
    print "            NCalls   : {0:<5d}".format(fitSuite.getNCalls())
    print '            par1     : {0:.4f} ({1:.3g}) '.format(height_found, height_diff)
    print '            par2     : {0:.4f} ({1:.3g}) '.format(radius_found, radius_diff)

    diff = 1.0e-02
    isSuccess = True
    if( (height_diff > diff) or (radius_diff > diff) ) : isSuccess=False
    return isSuccess

# -----------------------------------------------------------------------------
# create cylinders in the air
# -----------------------------------------------------------------------------
def buildSample():
    cylinder_ff = FormFactorCylinder(cylinder_height, cylinder_radius)
    n_particle = complex(1.0-6e-4, 2e-8)
    cylinder = Particle(n_particle, cylinder_ff)
    interference = InterferenceFunctionNone()

    particle_decoration = ParticleDecoration()
    particle_decoration.addParticle(cylinder)
    particle_decoration.addInterferenceFunction(interference)

    mAmbience = MaterialManager.getHomogeneousMaterial("Air", 1.0, 0.0 )
    air_layer = Layer(mAmbience)
    air_layer_decorator = LayerDecorator(air_layer, particle_decoration)
    multi_layer = MultiLayer()
    multi_layer.addLayer(air_layer_decorator)

    return multi_layer

def createSimulation():
    simulation = Simulation();
    simulation.setDetectorParameters(100, 0.0*degree, 2.0*degree,100 , 0.0*degree, 2.0*degree);
    simulation.setBeamParameters(1.0*angstrom, -0.2*degree, 0.0*degree);
    simulation.setBeamIntensity(1e10);
    return simulation

#-------------------------------------------------------------
# main()
#-------------------------------------------------------------
if __name__ == '__main__':
    name,description,status = runTest()
    print name,description,status
    if("FAILED" in status) : exit(1)
\end{lstlisting}


Output of functional test: fit module 2 params

TestFittingModule1.cpp with "Minuit2", "Migrad"

\begin{lstlisting}[style=eclipse,numbers=none]
FitSuitePrintObserver::update() -> Info. NCall:0 NStrategy:0 Chi2:6.26500281e+09
Time spend since last call, cpu:0.03 sec, wall time 0.03sec
   # 0 *height                                 4.00000000e+00  lim(0.01,)
   # 1 *radius                                 6.00000000e+00  lim(0.01,)
FitSuitePrintObserver::update() -> Info. NCall:20 NStrategy:0 Chi2:9.29429839e+07
Time spend since last call, cpu:1.27 sec, wall time 4.72sec
   # 0 *height                                 4.51488966e+00  lim(0.01,)
   # 1 *radius                                 4.68705140e+00  lim(0.01,)
FitSuitePrintObserver::update() -> Info. NCall:40 NStrategy:0 Chi2:9.74308159e+05
Time spend since last call, cpu:0.97 sec, wall time 1.05sec
   # 0 *height                                 4.94285364e+00  lim(0.01,)
   # 1 *radius                                 5.07666127e+00  lim(0.01,)
FitSuitePrintObserver::update() -> Info. NCall:60 NStrategy:0 Chi2:7.91181985e+00
Time spend since last call, cpu:1.00 sec, wall time 1.07sec
   # 0 *height                                 4.99977322e+00  lim(0.01,)
   # 1 *radius                                 4.99985065e+00  lim(0.01,)
FitSuitePrintObserver::update() -> Info. NCall:80 NStrategy:0 Chi2:1.01820395e-02
Time spend since last call, cpu:0.98 sec, wall time 1.05sec
   # 0 *height                                 5.00000020e+00  lim(0.01,)
   # 1 *radius                                 5.00000004e+00  lim(0.01,)

FitSuiteObserverPrint::update() -> Info. Printing results

--- FitSuite::printResults --------------------------
 Chi2:1.19798858e-02    chi2.NCall:85  grad.NCall:0,0,0 (neval, ngrad, total)
   # 0 *height                                 4.99999992e+00  lim(0.01,)
   # 1 *radius                                 5.00000004e+00  lim(0.01,)
-----------------------------------------------------
  MinimizerType          : Minuit2
  MinimizerAlgorithm     : Migrad
--- Options -----------------------------------------
  Strategy               : 1
  Tolerance              : 0.01
  MaxFunctionCalls       : 10000
  MaxIterations          : 10000
  Precision              : -1.00
  ErrorDefinition        : 1.00 (1-chi2, 0.5 likelihood)
  ExtraOptions           : 0
--- Status ------------------------------------------ 
  Status                 : 0 'OK, valid minimum'
  IsValidError           : 0 'No detailed error validation'
  CovMatrixStatus        : 3 'full accurate'
  NCalls                 : 85
  MinValue               : 1.01756899e-02
  Edm                    : 4.39332982e-12
--- Variables ---------------------------------------
  NumberOfVariables      : 2 (free), 2 (total) 
  Errors                 : yes, see below
      Npar  Name                                  Value         Error         GlobalCC      
      0    *height                                5.000000e+00  1.109913e-04  1.208255e-01  
      1    *radius                                5.000000e+00  8.941040e-05  1.208255e-01  
--- Correlations-------------------------------------
      1.000000e+00  -1.208255e-01 
      -1.208255e-01 1.000000e+00  
fitting1  : Real Time =   8.33 seconds Cpu Time =   4.58 seconds
\end{lstlisting}

