\newpage
\chapter{Fitting} \label{Fittingchap}

%     Minuit Library:
%         Migrad Algorithm ("Minuit", "Migrad"),
%         Simplex Algorithm ("Minuit", "Simplex")
%         Minimize Algorithm ("Minuit", "Minimize")
%         Scan Algorithm ("Minuit", "Scan")
%         Seek Algorithm ("Minuit", "Seek")
%     Fumili Library:
%         Fumili Algorithm
%     Minuit2 Library:
%         Migrad Algorithm ("Minuit2", "Migrad")
%         Simplex Algorithm ("Minuit2", "Simplex")
%         Minimize Algorithm ("Minuit2", "Minimize")
%         Scan Algorithm ("Minuit2", "Scan")
%         Fumili2 Algorithm ("Minuit2", "Fumili2")
%     GSL Library: (Only available if GSL and MathMore are available too)
%         Fletcher-Reeves Conjugate Gradient Algorithm ("GSLMultiMin", "conjugatefr")
%         Polak-Ribiere Conjugate Gradient Algorithm ("GSLMultiMin", "conjugatepr")
%         BFGS Conjugate Gradient Algorithm ("GSLMultiMin", "bfgs2")
%         Levenberg-Marquardt Algorithm ("GSLMultiFit", "")
%         Simulated Annealing Algorithm ("GSLSimAn", "")

In addition to the simulation of grazing incidence
X-ray and neutron scattering by
multilayered samples, \BornAgain\ also offers the option to
fit a selection of simulated sample parameters to reference data.  This aspect
of the software is discussed in the following chapter.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Short description of fitting theory}

%find the minimum value of a multi-parameter function and analyze the shape of the function around the minimum. The principal application is foreseen for statistical
%analysis, working on chisquare or log-likelihood functions, to compute the best-fit parameter values and
%uncertainties, including correlations between the parameters. It is especially suited to handle difficult
%problems, including those which may require guidance in order to find the correct solution.

These features of \BornAgain\ deal with estimating the optimum parameters
in the simulation by minimizing the difference ($\chi^2$) between
numerical and reference data.\\


\MakeRemark{Theory}{Users wanting to find out more about minimization (also called
maximization or optimization methods) are referred to \ldots.}\\

%The conjugate gradient and BFGS methods are described in detail in the following book,
%    R. Fletcher, Practical Methods of Optimization (Second Edition) Wiley (1987), ISBN 0471915475. 
%A brief description of multidimensional minimization algorithms and more recent references can be found in,
%    C.W. Ueberhuber, Numerical Computation (Volume 2), Chapter 14, Section 4.4 Minimization Methods, p. 325–335, Springer (1997), ISBN 3-540-62057-5
%The simplex algorithm is described in the following paper,
%    J.A. Nelder and R. Mead, A simplex method for function minimization, Computer Journal vol. 7 (1965), 308–313. 
% W. T. Eadie, D. Drijard, F. James, M. Roos, and B. Sadouletm
% Statistical methods in experimental physics, North-Holland 1971

Local minimum, multiple minima

Multidimensional fit = fit using multiple parameters??

Local or global minimization, Errors


From \Code{Minuit}'s documentation, In the common case of a least-squares
fit, the function to minimize is 
\begin{equation*}
\chi^2(\alpha)=\sum_{i=1}^n \frac{f(x_i,\alpha)-m_i}{\sigma_i^2}
\end{equation*}
where $\alpha$ is the vector of free parameters being fitted, and
$\sigma_i$ are the uncertainties in the individual measurements
$m_i$. If these uncertainties are not known, and are simply left out
of the calculation, then the fit may still have meaning, but not the
quantitative values of the resulting parameter errors. If the
$\sigma_i$ are all overestimated by a factor $\beta$, then the
resulting parameter errors from the fit will be overstimated by the
same factor $\beta$.

%\url{http://seal.web.cern.ch/seal/MathLibs/Minuit2/html/}

%\url{http://seal.web.cern.ch/seal/documents/minuit/mntutorial.pdf}

%\url{http://root.cern.ch/root/html/MATH_MINUIT2_Index.html}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Implementation in \BornAgain}
\BornAgain\ fitting features include different minimization
algorithms and strategies, a variety of potential fitting parameters. They are contained
in the ``Fit'' folder (a detailed description is given in \ldots). 

The minimization algorithms are provided by \Code{Root}. A detailed tutorial of \Code{Minuit} software can be downloaded at the
following address \url{http://seal.web.cern.ch/seal/documents/minuit/mnusersguide.pdf}.
%Different geometries, number of fit parameters, variety of minimizers\\
%and minimization strategies.\\
%Variable parameters: customize lists, inputs required, default values

%\textbf{From Minuit user's guide}: Minuit is usually used to find the ``best'' values of a set of
%parameters, where ``best'' is defined as those values which minimize a
%given function, FCN. The width of the function minimum in some
%neighbourhood of the minimum, gives information about the uncertainty
%in the best parameter values. An important feature of Minuit is that
%it offers several tools to analyze the parameter errors.\\

The fitting procedure deals with one reference (experimental) datafile. 
 
\textbf{Questions}
\begin{itemize}
\item background noise, intensity threshold, beam intensity 
\item Fit using several experimental runs?
\textbf{ Software Scatter:} The program allows to automatically fit large number of data files such as files from timeresolved
studies. A requirement is that subsequent scattering curves do not differ too much, so
that the fitted values of the first curve can be used as starting parameters for a fit to the next
curve. Before starting a fit series, choose the first data file and perform a fit so that the
parameter values are set to an optimal start value. The first/last point, qmin/max and Imin for
the fit will apply to all data sets.
\item Weighted fits?
\item Errorbars, epsilon for standard error - interpretation of values
  and associated errors
\item Normalisation of the data (in order to be compared)
\item Constraints between parameters
\item Quick fit option
\item Possible exponential decrease of the form factor
\item fit of 1D plots - possible
\item interrupt fit
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{General fitting procedure}

The general fitting procedure can be split into different steps:
\begin{enumerate}
\item Creation of the sample: multilayered sample, beam, detector,
\item Choice of the parameters to fit,
\item Loading experimental data,
\item Fit: linking the experimental and the numerical data, choice of
  minimizing algorithm (method, weights), running the fit, checking the fit's output.
\end{enumerate}

The class \texttt{FitSuite} contains the main functionalities to be used
for the fit. The following part of this paragraph will detail each of
these stages before applying them to an example.
%\begin{itemize}
%\item \texttt{addFitParameter}: choice of fitting parameters, 
%\item Adds pair of (simulation, real data) for consecutive simulation
%\texttt{addSimulationAndRealData(simulation, real\_data, chi2\_module)}
%\item \texttt{runFit()} : run the fit,
%\item  \texttt{initPrint(print\_every\_nth)} to print intermediate
 % results or \texttt{printResults()} to print the final ones
%\end{itemize}

%FitSuite::FitSuite() : m\_minimizer(0), m\_is\_last\_iteration(false)
%  m\_function\_chi2.init(this);m\_function\_gradient.init(this) 
%getNCalls() 
%    // running minimization using strategies
%    m\_fit\_strategies.minimize();

\subsubsection{Building the sample}
This step is similar for any simulation using \BornAgain. It
corresponds to first characterizing  the geometry of the system: the particles (shapes, sizes, refractive
indices), the different layers (thickness,
order, refractive index, a possible roughness of the interface), the
interference between the particles and the way they are distributed in
the layers (buried particles or particles sitting on top of a
layer). Then we specify the parameters of the input beam and of the
output detector.

\subsubsection{Loading reference data}
This is the data to which the fitting model will
be compared to. It usually refers to experimental data. We assume that it is a
two-dimensional intensity matrix as function of the output scattering
angles $\alpha_f$ and $\phi_f$ (see Fig.~\ref{fig:multil3d}). The format of the datafile can be ...

\subsubsection{Choice of parameters to be fitted}
In principle, every parameter used in the construction of the sample
can be used as a fit parameter. For example, the particles'
heights, radii or the layer's roughness or thickness could be selected
as fitting parameters. 


If the sample contains different types of particles, the heights of different particles can be associated to two different
fitting parameters and optimized / minimized separately.\\


In \BornAgain, the parameters used for the fit are specified using the
function \texttt{addFitParameter} with one of the following two lists
of variables:
\begin{itemize}
\item \texttt{(name, value, step, AttLimits, error)},
\item \texttt{(name, value, AttLimits, error)}
\end{itemize}
where \texttt{value}, \texttt{step} and \texttt{error} are double
values corresponding to the initial value of the parameter, the
iteration step and the error respectively. By default the input value
of \texttt{error} is 0. \texttt{AttLimits} corresponds to
the boundaries imposed on the range of variations of the fitting
parameter's value. It can be
\begin{itemize}
\item \texttt{fixed()}, 
\item \texttt{lowerLimited(min\_value)}, 
\item \texttt{limited(double min\_value, max\_value)}.
\end{itemize}
where \texttt{min\_value} and \texttt{max\_value} are
doubles corresponding to the lower and higher boundary respectively.
The unit of \texttt{AttLimits} is identical to the one used to characterize the
parameter.\\

\texttt{name} is the reference to the parameter as it was registered
using \texttt{RegisterParameter}. For example, to add the beam
intensity to the list, \texttt{name} would be
\texttt{"*Beam/intensity"}. In the case of the cylindrical particles's
 height, it would become \texttt{"*FormFactorCylinder/height"}.\\

\MakeRemark{Advice}{Initially choose a small number of fitting
  parameters.}

%\begin{table}[h]
%\centering
%\begin{tabular}{|@{}l||l@{}|}
%\hline
%\textbf{Particles} &  dimensions (depending on the shape): height, radius, length, width, \\
%                             &  half side length, thickness,
%                             inclination of the lateral faces,
 %                            \textbf{index of refraction}, \\
%&height
%                             aspect ratio, \textbf{orientation?}\\
%& position ($x, ,y, z$), depth, abundance \\
%& interference (density, proportion, width, distance, probability\\
%& dispersion radius) \\
%\hline
%\textbf{Lattice} & lengths of axis\\
%\hline
%\textbf{Layers} & roughness, thickness, \textbf{index of refraction} \\
%\hline
%\textbf{Beam} & intensity \\
%\hline
%\textbf{Detector} & \\
%\hline
%\end{tabular}
%\caption{List of potential fitting parameters.}
%\end{table}

%m\_cylinder\_ratio                   
% *Normalizer/scale,  *Normalizer/shift
% */lattice\_length\_a, */lattice\_length\_c   
%*/nanoparticle\_radius   
%*/sigma\_nanoparticle\_radius
% */meso\_height, */meso\_radius  
%*/sigma\_meso\_height, \_meso\_radius, \_lattice\_length\_a
%*/surface\_filling\_ratio
%*/roughness
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Associating reference and numerical data}
The function \texttt{addSimulationAndRealdData} links a given set of real data with a
  particular set of simulated data in order to proceed to a fit. It is
  therefore possible to generate a batch of different numerical
  samples to test different configurations in order to obtain the best
  fit by, for example, playing with the number of layers or the shape of particles
  (different form factors). 

There are two possible syntaxes to this function: 
\begin{lstlisting}[language=python, style=eclipse,numbers=none]
addSimulationAndRealData(simulation, real_data, chi2_module)

addSimulationAndRealData(simulation, real_data)
\end{lstlisting}
where \texttt{chi2\_module} is \textbf{give details}.

\texttt{setChiSquaredFunction}: SquaredFunctionWithSystematicError, SquaredFunctionDefault(), SquaredFunctionWhichOnlyWorks(),
\texttt{SquaredFunctionWithGaussianError(m\_sigma)}
,SquaredFunctionWithSystematicError(0.08) 
chiModule.setChiSquaredFunction(SquaredFunctionDefault()) ( isgisaxs
uses epsilon=0, which correspond to our SquaredFunctionDefault). 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Choice of fitting method}
%Number of iterations
Different minimizers from Root library can be used in \BornAgain. They are listed in
Table~\ref{table:fit_minimizers}. Users can also add their own by
implementing their definition in the \texttt{Catalogue} contained in
program \texttt{MinimizerFactory}.
Minuit user's manual describes which minimizer to use in order to best
fit your data \cite{MinuitRoot}.

\textbf{Is there any default method implemented?
Normalisation of data ?
How to change options of algorithms.}

\begin{table}[h]
\centering
\begin{tabular}{@{}ll@{}}
\hline
\hline
\textbf{Minimizer name - Library} & \textbf{Algorithm} \\
\hline
%Test & \\
%Scan & \\%[-3pt] 
Minuit & Migrad, Simplex, Combined, Scan\\
Minuit2 & Migrad, Simplex, Combined, Scan, Fumili \\
Fumili & \\
GSLMultiMin & ConjugateFR, ConjugatePR, BFGS, BFGS2, SteepestDescent \\
GSLMultiFit & \\
GSLSimAn & \\ %Simulated annealing algorithm
Genetic &  \\ %TMVA Toolkit for Multivariate Data Analysis with ROOT 
\hline
\hline
\end{tabular}
\caption{List of fitting minimizers implemented in \BornAgain.}
\label{table:fit_minimizers}
\end{table}

\begin{lstlisting}[language=python, style=eclipse,numbers=none]
FitSuite().setMinimizer(MinimizerFactory.createMinimizer("Minimizer
name","optional algorithm") )
\end{lstlisting}
where \texttt{Minimizer
name} and \texttt{optional algorithm} can be chose from first and
second column
of Table~\ref{table:fit_minimizers} respectively.

Four strategies have been implemented in \BornAgain\ and can be added
using the function \texttt{addFitStrategy}:
\begin{itemize}
\item \texttt{FitSuiteStrategyDefault} is the default fit strategy
  just let \texttt{FitSuite} run its minimization round,
\item \texttt{FitSuiteStrategyAdjustData} adjusts (rebins) the data before running fit suite minimization round,
\item \texttt{FitSuiteStrategyAdjustParameters} fixes/releases fit parameters and then call minimizer,
\item \texttt{FitSuiteStrategyBootstrap} helps the minimizer get out of local minima by perturbing real data.
\end{itemize}

%Minuit is conceived as a tool to find the minumum value of a
%multi-parameter function and analyze the shape of the function around
%the minimum. The principal application is foreseen for statistical
%analysis, working on chisquare or log-likelihood functions, to compute
%the best-fit parameter values and uncertainties, including
%correlations between the parameters. It is especially suite to handle
%difficult problems, including those which may requier guidance in
%order to find the correct solution.
%Minuit2, optional package in the ROOT framework, is a numerical minimization computer program
%originally written in C++ programming language. The program searches for minima in a user-defined function with
%respect to one or more parameters using several different methods as
%specified by the user. 
%MIGRAD
%This is the best minimizer for nearly all functions. It is a variable-metric method with inexact line search, a stable metric updating scheme, and checks for positive-definiteness. It will run faster if you SET STRATEGY 0 and will be more reliable if you SET STRATEGY 2 (although the latter option may not help much). Its main weakness is that it depends heavily on knowledge of the first derivatives, and fails miserably if they are very inaccurate. If first derivatives are a problem, they can be calculated analytically inside FCN (see elsewhere in this writeup) or if this is not feasible, the user can try to improve the accuracy of Minuit's numerical approximation by adjusting values using the SET EPS and/or SET STRATEGY commands (see Floating Point Precision and SET STRATEGY).
%SCAN
%This is not intended to minimize, and just scans the function, one parameter at a time. It does however retain the best value after each scan, so it does some sort of highly primitive minimization.
%SIMPLEX
%This genuine multidimensional minimization routine is usually much slower than MIGRAD, but it does not use first derivatives, so it should not be so sensitive to the precision of the FCN calculations, and is even rather robust with respect to gross fluctuations in the function value. However, it gives no reliable information about parameter errors, no information whatsoever about parameter correlations, and worst of all cannot be expected to converge accurately to the minimum in a finite time. Its estimate of EDM is largely fantasy, so it would not even know if it did converge. 
%Minuit2, originally developed in the SEAL project, is now distributed
%within ROOT. The classes have been moved inside the namespace
%ROOT::Minuit2. 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Outputs}
The output of the minimization could be saved in a file or printing on
the screen using the function \texttt{printResults()}. During the
fitting process, intermediate results can also be printed on the
screen with function \texttt{initPrint(print\_every\_nth)}, where
\texttt{print\_every\_nth} is the of the number of
 minimization iterations between outputs.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Example in Python}
In this section we are going to go through a complete example of
fitting using \BornAgain. Each of the steps will be associated with a
detailed piece of code written in Python. But the completed listing of
the script is given at the end (see Listing~\ref{script_exfit1}).\\

This example uses a simple sample geometry: cylindrical and
prismatic particles in equal proportion, in an air layer, deposited on a substrate layer, with no interference
between them.\\ We consider 4 fitting parameters: the radius and height of cylinders and the
side length and height of prisms.\\  Our "real" data is a 2D intensity
map obtained from the simulation of the same geometry with a fixed
value of 5 nanometers for the height of both particle shapes as well
as for the radius of the cylinders and the half side length of the
prisms' triangular basis.\\ Then we run our minimization consequently
using the algorithm Migrad from \Code{Minuit2} as a  minimization engine, starting with a cylinder's height
of 4~nm, a cylinder's radius of 6~nm, a prism's half side of 6~nm
and a length equal to 4~nm.\\

\MakeRemark{Order of steps}{The stages concerned with the preparation
  of the fit (generation of the sample, characteristics of the input
  beam and output detector, loading of reference data) can be interchanged.}

%%%%%%%%%%%%%%%%%%%%%
\myparagraph{\underline{Importing Python libraries and defining parameters}}

\begin{lstlisting}[language=python, style=eclipseboxed, name=exfit,nolol]
import sys, os, numpy 
import math @\label{import_libmath}@

sys.path.append(os.path.abspath(
                os.path.join(os.path.split(__file__)[0],
                '..', '..', '..', 'lib')))

from libBornAgainCore import * @\label{import_corelib}@
from libBornAgainFit import * @\label{import_fitlib}@

# values we want to find
cylinder_height = 5.0*nanometer @\label{cylheightini}@
cylinder_radius = 5.0*nanometer @\label{cylradini}@
prism3_half_side = 5.0*nanometer @\label{prismhlfini}@
prism3_height = 5.0*nanometer @\label{prismheightini}@
\end{lstlisting}

We start by importing different libraries required in order to run the script.
Lines~\ref{import_corelib} and \ref{import_fitlib} import two
\BornAgain\ libraries respectively linked with the generation of the
sample and with the fitting method.  

Then we specify the values that our fitting parameters should be equal
to at the end of the minimization (see lines~\ref{cylheightini}-\ref{prismheightini}).

%%%%%%%%%%%%%%%%%%%%%
\myparagraph{\underline{Building the sample}}

\begin{lstlisting}[language=python, style=eclipseboxed, name=exfit,nolol]
# ----------------------------------
# create sample : cylinders and prisms in the air on substrate layer
# ----------------------------------
def buildSample(): 
    # defining materials
    mAmbience = MaterialManager.getHomogeneousMaterial("Air", 0.0, 0.0 )
    mSubstrate = MaterialManager.getHomogeneousMaterial("Substrate", 6e-6, 2e-8 )
    # collection of particles
    n_particle = complex(6e-4, 2e-8)
    cylinder_ff = FormFactorCylinder(cylinder_height, cylinder_radius) @\label{fit_cylff}@
    cylinder = Particle(n_particle, cylinder_ff)
    prism_ff = FormFactorPrism3(prism3_height,  prism3_half_side) @\label{fit_prismff}@
    prism = Particle(n_particle, prism_ff)
    particle_decoration = ParticleDecoration()
    particle_decoration.addParticle(cylinder, 0.0, 0.5)
    particle_decoration.addParticle(prism,0.0, 0.5)  
    interference = InterferenceFunctionNone()
    particle_decoration.addInterferenceFunction(interference)
    # air layer with particles and substrate form multi layer
    air_layer = Layer(mAmbience)
    air_layer_decorator = LayerDecorator(air_layer, particle_decoration)
    substrate_layer = Layer(mSubstrate, 0)
    multi_layer = MultiLayer()
    multi_layer.addLayer(air_layer_decorator)
    multi_layer.addLayer(substrate_layer)
    return multi_layer

# ----------------------------------
# create sample: input beam and detector - characteristics
# ----------------------------------
def createSimulation():
    simulation = Simulation()
    simulation.setDetectorParameters(100, 0.0*degree, 2.0*degree,100 , 0.0*degree, 2.0*degree)
    simulation.setBeamParameters(1.0*angstrom, 0.2*degree, 0.0*degree)
    simulation.setBeamIntensity(1e10) @\label{fit_beamintensity}@
    return simulation
\end{lstlisting}

The details about the generation of this multilayered sample are given in \SecRef{Example1Python}.
The only difference can be seen in lines~\ref{fit_cylff},
\ref{fit_prismff}, where in this fitting example, we have to use names
for the fitting parameters instead of numerical values.
We also characterize the input beam and detector's parameters. 
 definition of the detector's using  \texttt{setBeamParameters},
 \texttt{setBeamIntensity} and \texttt{setDetectorParameters}
 respectively.\\

 
\MakeRemark{Units:}{ The beam intensity in line~\ref{fit_beamintensity} is expressed in \textbf{add units}.}

%%%%%%%%%%%%%%%%%%%%%
\myparagraph{\underline{Loading reference data}}

\begin{lstlisting}[language=python, style=eclipseboxed, name=exfit,nolol]
def GetRealData(): 
    real_data =
    OutputDataIOFactory.getOutputData('Refdata_fitcylinderprisms.txt') @\label{fit_input_realdata}@
    return real_data
\end{lstlisting}

Our reference data is contained in file 
\texttt{'Refdata\_fitcylinderprisms.txt'}, which contains a
two-dimensional array of the output intensity as a function of
$\alpha_f$ and $\phi_f$ (\textit{i.e.} the two output scattering
angles). In our case this reference had been generated by adding noise
on the scattered intensity from a numerical sample with a fixed length of 5~nm of the four fitting
parameters (\textit{i.e.} the dimensions of the cylinders and prisms).
 

%%%%%%%%%%%%%%%%%%%%%
\myparagraph{\underline{Preparing the fitting pair}}

\begin{lstlisting}[language=python, style=eclipseboxed,
  name=exfit,nolol]
def run_fitting(): @\label{Fit_function_run_fitting}@
    sample = buildSample() @\label{Fit_buildsample}@
    simulation = createSimulation() @\label{Fit_createsim}@
    simulation.setSample(sample) @\label{Fit_setsample}@

    # get the reference data
    real_data = GetRealData() @\label{Fit_getrealdata}@
    
    # run the simulation
    simulation.runSimulation() @\label{Fit_runsim}@

    # linking reference and numerical (to be fitted) data
    fitSuite = FitSuite() 
    fitSuite.addSimulationAndRealData(simulation, real_data) @\label{Fit_addrealsimdata}@
\end{lstlisting}


Lines~\ref{Fit_buildsample}-\ref{Fit_runsim} generate the numerical
model and load the reference data. Then with the \texttt{FitSuite}
class, we associate this pair with \texttt{addSimulationAndRealData}
(line~\ref{Fit_addrealsimdata}).\\


\ImportantPoint{Remark:}{\texttt{run\_fitting()} function (line~\ref{Fit_function_run_fitting}) is concerned
  with the full fitting procedure: preparing the fitting pair but also
  the next states of choosing the fitting parameters, the minimizer,
  and running the fit.
Therefore in Python, there is an identation for the script of the next
stages. This point is made clearer at the end of the section where the
full script is displayer.}
%%%%%%%%%%%%%%%%%%%%%
\myparagraph{\underline{Choice of fitting minimizer}}

\begin{lstlisting}[language=python, style=eclipseboxed,
  name=exfit,nolol]
    fitSuite.setMinimizer(
    MinimizerFactory.createMinimizer("Minuit2","Migrad") )  @\label{FitMinimizer}@
\end{lstlisting}

Line~\ref{FitMinimizer} implement our choice of minimizer for the
fit using the function \texttt{setMinimizer}. Several options are available in \BornAgain; they are listed in
Table~\ref{table:fit_minimizers}

%%%%%%%%%%%%%%%%%%%%%
\myparagraph{\underline{Choice of numerical parameters to be fitted}}

\begin{lstlisting}[language=python, style=eclipseboxed,
  name=exfit,nolol]
    fitSuite.addFitParameter("*FormFactorCylinder/height",
    4.*nanometer, 0.01*nanometer, AttLimits.lowerLimited(0.01) ) @\label{addFitparam_cheight}@
    fitSuite.addFitParameter("*FormFactorCylinder/radius",
    6.*nanometer, 0.01*nanometer, AttLimits.lowerLimited(0.01) ) @\label{addFitparam_cradius}@
    fitSuite.addFitParameter("*FormFactorPrism3/height", 4.*nanometer,
    0.01*nanometer, AttLimits.lowerLimited(0.01) ) @\label{addFitparam_pheight}@
    fitSuite.addFitParameter("*FormFactorPrism3/half_side",
    6.*nanometer, 0.01*nanometer, AttLimits.lowerLimited(0.01) ) @\label{addFitparam_phside}@
\end{lstlisting}

Lines~\ref{addFitparam_cheight}-\ref{addFitparam_phside} enter the
list of fitting parameters. Here we use the cylinders' height and
radius and the prisms' height and half side length. The syntax of
\texttt{addFitParameter} is
\begin{lstlisting}[language=python, style=eclipse,numbers=none]
FitSuite().addFitParameter(name, initial value, iteration step, limits)
\end{lstlisting}
where \texttt{name} is the name of the registered parameter selected
as a fitting parameter. Then we input its initial
value and the iteration step used in the minimization process. Finally
\texttt{limits} specify the boundaries of the parameter's value. Here
the cylinder's length and prism half side are initially equal to 4~nm,
whereas the cylinder's radius and the prism length are equal to 6~nm before the minimization. The
iteration step is equal to 0.01~nm and the boundaries are imposed only
on the lower one of 0.01~nm.\\


\ImportantPoint{Order of addition of fitting parameters}{The fitting
  parameters are stored in the order they are initialized. They can be
  accessed from the array
  \texttt{fitSuite.getFitParameters().getValues()} indexed from 0.}

%%%%%%%%%%%%%%%%%%%%%
\myparagraph{\underline{Running the fit}}

\begin{lstlisting}[language=python, style=eclipseboxed, name=exfit,nolol]
    # run fit 
    fitSuite.runFit()    @\label{runFit}@
    # print fit results
    fitSuite.printResults() @\label{printFitresults}@
\end{lstlisting}

Line~\ref{runFit} shows the command to start the minimization
process. For this example we chose to display the final results only
using the function \texttt{printResults()} (see
line~\ref{printFitresults}). But intermediate results are accessible as
mentioned above with the command \texttt{printLine(number of
 minimization iterations between prints)}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
After running the fit, whose script is shown in
Listing~\ref{script_exfit1}, the text given in~\ref{output_exfit1} should be displayed on your
screen (generated using \texttt{PrintResults}).

\begin{lstlisting}[caption={Python script of fitting example},
  label=script_exfit1,captionpos=b,escapeinside={@}{@} ,language=python,style=eclipse, numbers= none,frame = leftline ,
      framerule = 2mm ,
      rulecolor = \color{lightgrey},
      breaklines = true]
import sys, os, numpy
import math 

sys.path.append(os.path.abspath(
                os.path.join(os.path.split(__file__)[0],
                '..', '..', '..', 'lib')))

from libBornAgainCore import *
from libBornAgainFit import *

# values we want to find
cylinder_height = 5.0*nanometer
cylinder_radius = 5.0*nanometer
prism3_half_side = 5.0*nanometer
prism3_height = 5.0*nanometer
# ----------------------------------
# create sample : cylinders and prisms in the air on substrate layer
# ----------------------------------
def buildSample(): 
    # defining materials
    mAmbience = MaterialManager.getHomogeneousMaterial("Air", 0.0, 0.0 )
    mSubstrate = MaterialManager.getHomogeneousMaterial("Substrate", 6e-6, 2e-8 )
    # collection of particles
    n_particle = complex(6e-4, 2e-8)
    cylinder_ff = FormFactorCylinder(cylinder_height, cylinder_radius)
    cylinder = Particle(n_particle, cylinder_ff)
    prism_ff = FormFactorPrism3(prism3_height,  prism3_half_side)
    prism = Particle(n_particle, prism_ff)
    particle_decoration = ParticleDecoration()
    particle_decoration.addParticle(cylinder, 0.0, 0.5)
    particle_decoration.addParticle(prism,0.0, 0.5)  
    interference = InterferenceFunctionNone()
    particle_decoration.addInterferenceFunction(interference)
    # air layer with particles and substrate form multi layer
    air_layer = Layer(mAmbience)
    air_layer_decorator = LayerDecorator(air_layer, particle_decoration)
    substrate_layer = Layer(mSubstrate, 0)
    multi_layer = MultiLayer()
    multi_layer.addLayer(air_layer_decorator)
    multi_layer.addLayer(substrate_layer)
    return multi_layer
# ----------------------------------
# create sample : input beam and detector - characteristics
# ----------------------------------
def createSimulation():
    simulation = Simulation()
    simulation.setDetectorParameters(100, 0.0*degree, 2.0*degree,100 , 0.0*degree, 2.0*degree)
    simulation.setBeamParameters(1.0*angstrom, 0.2*degree, 0.0*degree)
    simulation.setBeamIntensity(1e10) # to leave or not
    return simulation
# ----------------------------------
# read "real" data from file
# ----------------------------------
def GetRealData():
    real_data = OutputDataIOFactory.getOutputData('Refdata_fitcylinderprisms.txt')
    return real_data
# ----------------------------------
# run fitting 
# ----------------------------------
def run_fitting():
    sample = buildSample()
    simulation = createSimulation()
    simulation.setSample(sample)
    # get the real data, which is simply results of our simulation with default values
    real_data = GetRealData()   
    # run the simulation
    simulation.runSimulation()    
    # linking real and numerical (to be fitted) data
    fitSuite = FitSuite()
    fitSuite.addSimulationAndRealData(simulation, real_data)  
    # setting fitting minimizer
    fitSuite.setMinimizer( MinimizerFactory.createMinimizer("Minuit2","Migrad") ) 
    # setting fitting parameters
    fitSuite.addFitParameter("*FormFactorCylinder/height", 4.*nanometer, 0.01*nanometer, AttLimits.lowerLimited(0.01) )
    fitSuite.addFitParameter("*FormFactorCylinder/radius", 6.*nanometer, 0.01*nanometer, AttLimits.lowerLimited(0.01) )
    fitSuite.addFitParameter("*FormFactorPrism3/height", 4.*nanometer, 0.01*nanometer, AttLimits.lowerLimited(0.01) )
    fitSuite.addFitParameter("*FormFactorPrism3/half_side", 6*nanometer, 0.01*nanometer, AttLimits.lowerLimited(0.01) )
    # run fit
    fitSuite.runFit()
    # print fit results
    fitSuite.printResults()
\end{lstlisting}

%# ----------------------------------
%# main()
%# ----------------------------------
%if __name__ == '__main__':
%    run_fitting()


\begin{lstlisting}[caption={Output of fit using Python script~\ref{script_exfit1}},language=bash,basicstyle=\small\lstfontfamily,% style=commandline,
  label=output_exfit1,captionpos=b,escapeinside={@}{@}, numbers= none]%,breaklines = true]
--- FitSuite::printResults --------------------------
 Chi2:6.06100495e-07    chi2.NCall:159  grad.NCall:0,0,0 (neval, ngrad, total)
   # 0 *FormFactorCylinder/height          4.99997446e+00  lim(0.01,)
   # 1 *FormFactorCylinder/radius         5.00001015e+00  lim(0.01,)
   # 2 *FormFactorPrism3/height           5.00000526e+00  lim(0.01,)
   # 3 *FormFactorPrism3/half_side        4.99998321e+00  lim(0.01,)
-----------------------------------------------------
  MinimizerType          : Minuit2
  MinimizerAlgorithm     : Migrad
--- Options -----------------------------------------
  Strategy               : 1
  Tolerance              : 0.01
  MaxFunctionCalls       : 10000
  MaxIterations          : 10000
  Precision              : -1.00
  ErrorDefinition        : 1.00 (1-chi2, 0.5 likelihood)
  ExtraOptions           : 0
--- Status ------------------------------------------ 
  Status                 : 0 'OK, valid minimum'
  IsValidError           : 0 'No detailed error validation'
  CovMatrixStatus        : 3 'full accurate'
  NCalls                 : 159
  MinValue               : 2.11285899e-07
  Edm                    : 2.02968770e-08
--- Variables ---------------------------------------
  NumberOfVariables      : 4 (free), 4 (total) 
  Errors                 : yes, see below
  Npar  Name                                  Value         Error         GlobalCC      
  0   *FormFactorCylinder/height       4.999974e+00  2.545638e-01  5.698257e-01  
  1   *FormFactorCylinder/radius       5.000010e+00  1.336151e-01  2.309216e-02  
  2   *FormFactorPrism3/height         5.000005e+00  1.730972e-01  5.697503e-01  
  3   *FormFactorPrism3/half_side      4.999983e+00  3.100541e-01  2.897434e-02  
--- Correlations-------------------------------------
      1.000000e+00  7.770605e-03  -5.695874e-01 1.079534e-02  
      7.770605e-03  1.000000e+00  -1.702212e-03 -2.134996e-02 
      -5.695874e-01 -1.702212e-03 1.000000e+00  7.135700e-03  
      1.079534e-02  -2.134996e-02 7.135700e-03  1.000000e+00  
\end{lstlisting}

